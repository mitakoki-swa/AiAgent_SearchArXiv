Title: Efficient Distributed Retrieval-Augmented Generation for Enhancing Language Model Performance

URL Source: http://arxiv.org/pdf/2504.11197v2

Published Time: Thu, 17 Apr 2025 00:23:31 GMT

Markdown Content:
# Efficient Distributed Retrieval-Augmented Generation for Enhancing Language Model Performance 

# Shangyu Liu 1, Zhenzhe Zheng 1, Xiaoyao Huang 2, Fan Wu 1, Guihai Chen 1 Jie Wu 2

> 1

Shanghai Jiao Tong University 

> 2

Cloud Computing Research Institute, China Telecom {liushangyu,zhengzhenzhe}@sjtu.edu.cn, huangxy32@chinatelecom.cn, {fwu,gchen}@cs.sjtu.edu.cn, wujie@chinatelecom.cn 

## Abstract 

Small language models (SLMs) support efficient deployments on resource-constrained edge devices, but their limited capacity com-promises inference performance. Retrieval-augmented generation (RAG) is a promising solution to enhance model performance by in-tegrating external databases, without requiring intensive on-device model retraining. However, large-scale public databases and user-specific private contextual documents are typically located on the cloud and the device separately, while existing RAG implemen-tations are primarily centralized. To bridge this gap, we propose DRAGON, a distributed RAG framework to enhance on-device SLMs through both general and personal knowledge without the risk of leaking document privacy. Specifically, DRAGON decom-poses multi-document RAG into multiple parallel token generation processes performed independently and locally on the cloud and the device, and employs a newly designed Speculative Aggregation, a dual-side speculative algorithm to avoid frequent output synchro-nization between the cloud and device. A new scheduling algorithm is further introduced to identify the optimal aggregation side based on real-time network conditions. Evaluations on real-world hard-ware testbed demonstrate a significant performance improvement of DRAGONâ€”up to 1.9Ã— greater gains over standalone SLM com-pared to the centralized RAG, substantial reduction in per-token latency, and negligible Time to First Token (TTFT) overhead. 

## 1 Introduction 

Although large language models (LLMs) such as GPT-4 [ 42 ] and DeepSeek-V3 [ 13 ] have demonstrated remarkable performance in real-world applications, their substantial deployment costs have led to predominant cloud-based hosting. As a result, users are required to upload private context along with their queries, raising serious privacy concerns [ 12 ]. Recently, small language models (SLMs) such as Phi-4-mini [ 1 ] and Qwen2.5-1.5B [ 57 ], have emerged as promising alternatives, offering efficient local deployment on edge devices. However, although SLMs are notably smaller than cloud-hosted LLMsâ€”leading to reduced performance on both personal and general tasksâ€”they still remain too large for resource-constrained devices to support on-device fine-tuning or training [ 27 ] to adapt to newly generated data and user feedback. Retrieval-augmented generation (RAG) [ 36 , 46 ] has demonstrated effectiveness in boosting the performance of SLMs by incorporating contextually relevant documents from external databases, such as Wikipedia [ 4 ]. The performance gain increases monotonically with the scale of the database [ 49 ], showing an opportunity for SLMs to achieve comparable or even better performance than standalone LLMs [ 11 ]. More importantly, by expanding user-specific external Distributed  

> Retrieval
> Centralized RAG

++ + ++            

> Aggregate
> Rusty Lake 2
> simulation 1
> puzzle 1
> The Sims 2
> simulation 1
> Stardew Valley 2
> long wait
> Stardew Valley 2
> simulation 1
> Distributed
> RAG
> Cloud Device
> I like games, among which is a hot seller on Steam. â‘ â‘¡
> Language models
> Cloud -Only Device -Only

Figure 1: Comparison between different RAG architectures. 

database (also known as the non-parametric memory [ 36 ]), model customization and knowledge updates can be achieved efficiently without model training. Typically, large-scale public databases con-taining general knowledge are hosted in the cloud, whereas user-specific private databases are maintained on-device. Since the query context may involve both general and personal data, it is essential for retrieval-augmented SLMs to support distributed databases lo-cated in the cloud and device. Unfortunately, most existing RAG so-lutions [ 7 , 36 , 46 ] adopt a centralized architecture. Figure 1 presents an example of game recommendation. The cloud-only RAG returns an incorrect game genre, although private documents indicate a preference for simulation games. In contrast, the device-only RAG fails to retrieve the best-selling game lists without accessing to the general knowledge in the cloud. An intuitive solution, similar to federated search [ 52 ], is to re-trieve documents from the cloud-side database, merge them with those retrieved locally on-device, and perform model inference in a centralized manner. However, this approach may incur substan-tial latency overhead considering key-value (KV) caching [ 64 ], a fundamental mechanism in language model serving that stores intermediate attention states to enable efficient reuse of past com-putations. Given a context sequence length ğ‘› , the KV cache trades 

ğ‘‚ (ğ‘› ) storage for a reduction in decoding time complexity from 

ğ‘‚ (ğ‘› 2) to ğ‘‚ (ğ‘› ). Therefore, the KVs of documents are often pre-computed, stored in the database, and retrieved. This leads to a dilemma: when retrieving the raw text of cloud-side documents, the device must compute their KVs from scratch, incurring signifi-cant computation latency; Conversely, directly retrieving the KVs from the cloud introduces substantial transmission latency, as the size of KVs can be comparable to, or even larger than, the model parameters, especially as the number of document grows [18]. 

> arXiv:2504.11197v2 [cs.LG] 16 Apr 2025

To address these issues, we propose DRAGON, a d istributed r etrieval- augmented generati on framework designed to enhance the performance of on-device language model inference. Follow-ing the Law of Total Probability, DRAGON first decomposes the multi-document RAG process into a dual-side workflow, and then aggregates their output tokens for the final result. In this workflow, the cloud and device sides independently execute their own LM instances using documents retrieved from their databases. Docu-ment KVs are stored and loaded locally without transmission or re-computation, thereby reducing first-token latency and preserv-ing document privacy. Nonetheless, the output aggregation requires frequent exchange of data packets between the cloud and device at every token generation step, due to the auto-regressive nature of language models. This transmission pattern requires a persistent low-latency connection between the cloud and device, which is difficult to guarantee in real-world scenarios [39, 40]. To solve this challenge, we draw inspiration from the draft-then-verify paradigm in Speculative Decoding [33 ] and propose a new dual-side speculative algorithm, namely Speculative Aggregation . In this algorithm, the decoding processes on both sides continuously generates draft tokens, and an Aggregator on either side (depending on certain scheduling criteria) asynchronously verifies and aggre-gates them. Decoding is interrupted and the corresponding KV states are rolled back for re-computation only when a draft is re-jected. As our theoretical analysis proves the equivalence between Speculative Aggregation and the vanilla synchronized version, the end-to-end latency can be reduced by overlapping transmission and decoding processes, especially when the output distributions of the two sides are similar. We implement a fully functional distributed RAG workflow and construct a testbed using real-world hardware. Based on this, we evaluate DRAGON against various RAG architectures using repre-sentative SLMs on large-scale retrieval corpora and datasets. Exper-imental results of language modeling on WikiText demonstrate that DRAGON achieves 1.9Ã— and 1.4Ã— greater performance gains over the standalone SLM than the centralized method, using Qwen2.5-1.5B and OPT-1.3B, respectively. Moreover, DRAGON shows strong robustness under various network conditions and achieves a 42.4%-49.5% reduction in per-token latency compared to synchronized methods under 300 ms network latency. While retrieving raw text and KV states incurs up to 8.9Ã— and 15 .3Ã— overhead in response time, DRAGON introduces negligible overhead. Extensive simula-tions further verify that the proposed scheduling algorithm achieves increasing delay reduction as network latency grows. We summarize the key contributions of this work as follows: 

â€¢ We propose DRAGON, the first distributed RAG system that sup-ports distributed documents retrieval and collaborative output generation between cloud and device. It significantly enhances the performance of on-device SLMs with the integration of both personal and general knowledge. 

â€¢ We introduce Speculative Aggregation , a dual-side speculative algorithm that decouples synchronized aggregation from sequen-tial decoding by asynchronously verifying the output alignment between cloud and device, greatly reducing end-to-end latency. 

â€¢ We further design an adaptive scheduling algorithm to dynam-ically identify the optimal aggregation side under varying net-work conditions, effectively improving decoding efficiency. 

â€¢ We implement DRAGON in a real-world hardware testbed and perform comprehensive evaluations using representative SLMs and large-scale retrieval corpora, demonstrating significant per-formance improvements of on-device SLMs with negligible over-head even under high-latency network conditions. 

## 2 Preliminaries 2.1 Retrieval-Augmented Generation 

Retrieval-augmented generation [ 36 ] integrates off-the-shelf lan-guage models with documents retrieved from an external database to capture long-tail knowledge and keep up-to-date with new infor-mation. In traditional LM inference, given an input token sequence 

ğ‘¥ <ğ‘€ = {ğ‘¥ 0, . . . , ğ‘¥ ğ‘€ âˆ’1} (indices of tokens in vocabulary ğ‘‰ ) and the maximum context length ğ‘ , the output generation process aims to maximize the probability Ãğ‘ âˆ’1 

> ğ‘¡ =ğ‘€

ğ‘ (ğ‘¥ ğ‘¡ |ğ‘¥ <ğ‘¡ ). In order to incorporate external documents, we process each document concatenated with the query separately, and then interpolate the output distributions (termed as output aggregation [ 3, 36 , 51 ]) 1. Following the Law of Total Probability, we can derive the interpolation as 

ğ’‘ (ğ‘¥ ğ‘¡ |ğ‘¥ <ğ‘¡ ) =âˆ‘ï¸ ğ‘‘ âˆ¼ğ‘ (ğ‘‘ ) ğ‘ (ğ‘‘ |ğ‘¥ <ğ‘¡ ) Â· ğ’‘ (ğ‘¥ ğ‘¡ |ğ‘‘, ğ‘¥ <ğ‘¡ ), (1) where ğ‘ (ğ‘‘ |ğ‘¥ <ğ‘¡ ) denotes the weight of the document ğ‘‘ on the out-put distribution ğ’‘ (ğ‘¥ ğ‘¡ |ğ‘‘, ğ‘¥ <ğ‘¡ ). Since ğ‘ (ğ‘‘ |ğ‘¥ <ğ‘¡ ) cannot be directly obtained in practice, we retrieve ğ‘‘ from a sufficiently large corpus 

D and only consider top-ğ‘˜ documents with the highest relevance score RD (ğ‘‘, ğ‘¥ <ğ‘¡ ). Equation (1) offers the opportunity to decom-pose the multi-document RAG workflow into parallel generation processes, enabling device-cloud distributed RAG. This decomposi-tion also significantly alleviates the limitation of maximum context length on resource-constraint devices. 

## 2.2 Device-Cloud Distributed RAG 

To enhance the performance of on-device LLM inference, we pro-pose a device-cloud distributed RAG framework based on the above discussed output aggregation paradigm. Given an input ğ‘¥ <ğ‘¡ , we retrieve personalized documents ğ· device from a device-side private database and then compute the next-token distributions ğ‘· device  

> ğ‘¡

=

ğ’‘ (ğ‘¥ ğ‘¡ |ğ‘‘, ğ‘¥ <ğ‘¡ )âŠ¤  

> ğ‘‘ âˆˆğ· device

using an on-device LLM Mdevice . In paral-lel, we employ a similar process in the cloud and obtain the cloud-side next-token distributions ğ‘· cloud  

> ğ‘¡

. After gathering all documents 

ğ· = ğ· device âˆª ğ· cloud and their corresponding output distributions 

ğ‘· ğ‘¡ = ğ‘· device  

> ğ‘¡

, ğ‘· cloud 

> ğ‘¡

âŠ¤, we sample the next token according to 

ğ‘¥ ğ‘¡ âˆ¼ ğ âŠ¤ 

> ğ‘¡

ğ‘· ğ‘¡ =âˆ‘ï¸ ğ‘‘ âˆˆğ· ğœ” ğ‘¡ (ğ‘‘ ) Â· ğ’‘ (ğ‘¥ ğ‘¡ |ğ‘‘, ğ‘¥ <ğ‘¡ ), (2) where ğ ğ‘¡ = ğœ” ğ‘¡ (ğ‘‘ )âŠ¤  

> ğ‘‘ âˆˆğ·

denotes the interpolation weights, which are computed based on relevance scores R as 

ğœ” ğ‘¡ (ğ‘‘ ) = exp R ( ğ‘‘, ğ‘¥ <ğ‘¡ )/ âˆ‘ï¸ ğ‘‘ â€² âˆˆğ· exp R ( ğ‘‘ â€², ğ‘¥ <ğ‘¡ ).

We refer to this workflow as the vanilla distributed RAG.      

> 1The output aggregation is different from context aggregation [46 ]), where external documents are concatenated and prepended to the input query ğ‘¥ <ğ‘¡ all at once.

2Despite its effectiveness, frequent synchronization between the device and the cloud can introduce a substantial latency. On one hand, the tight data coupling in distributed RAG leads to idle wait-ing, especially when decoding latencies significantly differ due to hardware heterogeneity in cloud and device. During the auto-regressive LLM model inference, the output ğ‘¥ ğ‘¡ âˆ’1 is expected on both sides as the input for generating ğ‘· ğ‘¡ . At each token genera-tion step ğ‘¡ , computing Equation (2) requires waiting for both the device-side and cloud-side output distributions, ğ‘· device  

> ğ‘¡

and ğ‘· cloud  

> ğ‘¡

.On the other hand, frequent transmission of data packets makes this device-cloud distributed RAG paradigm highly sensitive to network stability. Transmitted data packets at each step includes a 2-byte integer representing the token ğ‘¥ ğ‘¡ and a float matrix ğ‘· ğ‘¡ 

encoding the output distributions 2. Due to the small data packet size, transmission time is often dominated by data-independent fac-tors [9, 20], such as the connection round-trip time (RTT). Finally, idle waiting and transmission latency at each token generation step accumulate over a long output sequence, significantly amplifying the overall overhead. 

## 2.3 Problem Formulation 

We define the LLM inference as a distributed process where the device-side and cloud-side token generation processes, F device and 

F cloud , executes alternatively. We assume the final output token sequence is generated on-device by sampling ğ‘¥ âˆ¼ ğ’‘ ğ‘¡ . Let ğ´ ğ‘¡ be an auxiliary set for transferring information between the device and the cloud at iteration ğ‘¡ , which is initially empty, and let ğ’‘ ğ‘¡ denote the next-token distribution. The workflow can then be expressed as 

ğ´ device  

> ğ‘¡

, ğ’‘ ğ‘¡ â† F device (ğ´ cloud   

> ğ‘¡ âˆ’1

, Mdevice , ğ· device , ğ‘¥ <ğ‘¡ ) on the device, and ğ´ cloud  

> ğ‘¡

â† F cloud (ğ´ device  

> ğ‘¡

, Mcloud , ğ· cloud , ğ‘¥ <ğ‘¡ ) on the cloud, respectively. Finally, the optimization objective is given by 

min 

> F

1

ğ‘ âˆ‘ï¸ 

> ğ‘ ğ‘¡ =1

 âˆ’ğ‘ (ğ‘¥ âˆ— 

> ğ‘¡

|ğ‘¥ <ğ‘¡ ) log ğ’‘ ğ‘¡ (ğ‘¥ âˆ— 

> ğ‘¡

|ğ‘¥ <ğ‘¡ ) + ğœ†ğ¶ (ğ´ ğ‘¡ , F )  , (3) where ğ‘¥ âˆ— 

> ğ‘¡

represents the optimal token at step ğ‘¡ and ğ¶ denotes the end-to-end latency per token resulted from the transmission of ğ´ ğ‘¡ 

and execution of F between the cloud and device. The coefficient 

ğœ† controls the trade-off between performance and efficiency. 

## 3 Overview of DRAGON 

To enhance on-device LLM inference while minimizing the latency overhead, we propose DRAGON, a device-cloud distributed RAG framework. In this framework, we sample tokens from distribu-tions aggregated from the device-side and cloud-side RAG outputs, enabling an integration of personalized information and generic knowledge. To mitigate the inherent latency caused by frequent device-cloud synchronizations in vanilla distributed RAG, we per-form distribution aggregation and next-token sampling in a spec-ulative manner, where draft tokens are generated on both sides and then verified on either side. Accordingly, as shown in Figure 2, DRAGON consists of four modules deployed on both sides, in-cluding Decoders, Queues, Profilers, and Schedulers, along with a device/cloud-switchable Aggregator on either side.                                  

> 2The float matrix ğ‘· ğ‘¡ has a size of |ğ‘‰ |max ( | ğ· device |,|ğ· cloud | ) , where the vocabulary size |ğ‘‰ |is typically less than 50,000. â€œscienceâ€ â€œandâ€ â€œtechnologyâ€
> â€œgamesâ€ â€œ.â€
> Draft Queues
> â€œIâ€ â€œloveâ€ â€œcomputerâ€
> Target Queue
> â€œgamesâ€
> â€œscienceâ€
> â€œgamesâ€
> decode()
> â€œ.â€
> Aggregator
> +
> Scheduler
> Decoder
> +
> â¶â·
> â¸
> â¹â¹
> Decoder Draft &Target Queues
> Transmission Bus
> Device
> Cloud
> Query Target token Acceptance status Draft tokens and output distributions

Figure 2: Overview of the DRAGON framework. 

We organize Decoders, Queues and Aggregator by a producer-consumer paradigm, enabling asynchronous decoding of draft to-kens. The Decoder serves as a token producer, and on each side 

ğ‘  âˆˆ { device , cloud } it decodes draft tokens ğ‘¥ ğ‘  ğ‘¡ independently based on locally-aggregated output distributions ğ’‘ ğ‘  ğ‘¡ = ( Ëœğ ğ‘  ğ‘¡ )âŠ¤ğ‘· ğ‘  ğ‘¡ where 

Ëœğ ğ‘¡ = ğœ” ğ‘¡ (ğ‘‘ )âŠ¤  

> ğ‘‘ âˆˆğ· ğ‘ 

, similar to Equation (2) but using the retrieved local documents ğ· ğ‘  only ( 1 ). The draft tokens ğ‘¥ ğ‘  ğ‘¡ and their cor-responding distribution vectors ğ’‘ ğ‘  ğ‘¡ are broadcast to the other side. On each side, we enqueue ğ‘¥ ğ‘  ğ‘¡ into Draft Queues ( 2 ). The Aggrega-tor, as a consumer, continuously consumes draft tokens from the front of local queues and performs aggregation process ( 3 ). Sub-sequently, the aggregation results of the draft token are broadcast to Draft Queues on both sides. For each queue, the first token is dequeued if accepted, or the entire queue is cleared if rejected. The final target token output by Aggregator is enqueued into Target Queue on both sides ( 4 ). Although the dependencies between the aggregator and decoder cannot be eliminated, the data transmission latency can be overlapped with the decoding time, mitigating idle waiting. To accommodate dynamic computing resources on both sides and network bandwidth between them, we further design Profilers and Schedulers to identify the optimal aggregation side. 

## 4 Speculative Aggregation 

Inspired by Speculative Decoding [ 33 ], we propose Speculative Ag-gregation to reduce the device-cloud communication latency. Spec-ulative Decoding adopts a draft-then-verify decoding paradigm to reduce the number of calls to the resource-intensive LLM. Simi-larly, Speculative Aggregation utilizes two independent decoding processes, the device-side and cloud-side Decoders, to draft mul-tiple candidate future tokens, which are then verifies through an Aggregator. This is equivalent to directly sampling from the dis-tributions aggregated from the device-side and cloud-side outputs. As the aggregation involves collecting output distributions over the network, we expect the speculative algorithm to reduce its frequency and mitigate data transmission costs. More specifically, the Aggregator stays in a blocked wait state until both local Draft Queues are non-empty. Once this condition is met, it retrieves one token ğ‘¥ device  

> ğ‘¡

/ğ‘¥ cloud  

> ğ‘¡

from the front of each 3queue and fetches corresponding locally-aggregated output distri-butions ğ’‘ device  

> ğ‘¡

/ğ’‘ cloud  

> ğ‘¡

from the cache. The tokens and the distribu-tions are then provided as inputs to the aggregation. Subsection 4.1 presents the target distribution of the aggregation while Subsec-tion 4.2 introduces an speculative strategy to sample from the target distribution equivalently. Subsection 4.3 analyzes the acceptance probability, providing guidance for further scheduling design. Since the workflows of the device and cloud sides are designed to be symmetric, we define {ğ‘™, ğ‘Ÿ } = {device , cloud } to maintain general-ity and avoid repetition. From the perspective of the Aggregator, ğ‘™ 

refers to the local side that performs aggregation, while ğ‘Ÿ denotes the remote side, which only generates draft tokens. 

## 4.1 Target Token Distribution 

The objective of speculative aggregation is to generate tokens that are equivalent to those sampled from the target distribution 

ğ’‘ ğ‘¡ = ğ âŠ¤ 

> ğ‘¡

ğ‘· ğ‘¡ as defined in Equation (2) . We partition ğ‘· ğ‘¡ block-wise, grouping its distribution vectors by generation side, and have 

ğ’‘ ğ‘¡ = (ğ ğ‘™ ğ‘¡ )âŠ¤ğ‘· ğ‘™ ğ‘¡ + ( ğ ğ‘Ÿ ğ‘¡ )âŠ¤ğ‘· ğ‘Ÿ ğ‘¡ . For each ğ‘  âˆˆ { ğ‘™, ğ‘Ÿ }, we have ğ ğ‘™ ğ‘¡ = ğœ‚ ğ‘  ğ‘¡ Ëœğ ğ‘™ ğ‘¡ 

where ğœ‚ ğ‘  ğ‘¡ = â„ğ‘  ğ‘¡ /( â„ğ‘™ ğ‘¡ +â„ğ‘Ÿ ğ‘¡ ) and â„ğ‘  ğ‘¡ = Ãğ‘‘ âˆˆğ· ğ‘  exp R ( ğ‘‘, ğ‘¥ <ğ‘¡ ). As a result, given the locally-aggregated output distributions ğ’‘ ğ‘™ ğ‘¡ and ğ’‘ ğ‘Ÿ ğ‘¡ (Â§ 3), the target distribution ğ’‘ ğ‘¡ can be obtained by an interpolation: 

ğ’‘ ğ‘¡ = ğœ‚ ğ‘™ ğ‘¡ ğ’‘ ğ‘™ ğ‘¡ + ğœ‚ ğ‘Ÿ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ . (4) To align with this computation process, on each side ğ‘  âˆˆ { ğ‘™, ğ‘Ÿ }, a corrected value 3 of â„ğ‘  ğ‘¡ is computed and retained during decoding 

ğ‘¥ ğ‘  ğ‘¡ , and then broadcast and stored along with draft tokens and the locally-aggregated distributions. 

Dynamic weights. The interpolation weights ğœ‚ ğ‘™ ğ‘¡ and ğœ‚ ğ‘Ÿ ğ‘¡ in Equa-tion (4) can be dynamic, as the relevance between documents and the ongoing context may vary during generation. While current studies [ 36 , 51 ] that employ output aggregation adopt static doc-ument relevance scores, we explore dynamic weights by adopt-ing a strategy inspired by those used in recommendation systems. Upon receiving the input query ğ‘¥ <ğ‘€ , each side ğ‘  âˆˆ { ğ‘™, ğ‘Ÿ } performs a one-time retrieval of a relatively large document set ğ· ğ‘  (as in most existing works [ 23 , 35 , 51 ]) to avoid key-value recomputation caused by changes in the document prefix. During the decoding of draft token ğ‘¥ ğ‘¡ , we re-estimate the relevance scores R ( ğ‘‘, ğ‘¥ <ğ‘¡ ) for 

ğ‘‘ âˆˆ ğ· ğ‘  using a local re-ranking model (e.g., a Cross-Encoder [ 48 ]) and re-calculate the corrected â„ğ‘  ğ‘¡ before transmission. 

## 4.2 Design of Aggregation Strategy 

To sample ğ‘¥ ğ‘¡ âˆ¼ ğ’‘ ğ‘¡ , we instead perform two independent speculative sampling processes as follows: 

â€¢ Keep the draft token ğ‘¥ ğ‘™ ğ‘¡ as Ëœğ‘¥ ğ‘™ ğ‘¡ if ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ğ‘™ ğ‘¡ ) â‰¤ ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ğ‘™ ğ‘¡ ), and in case 

ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ğ‘™ ğ‘¡ ) > ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ğ‘™ ğ‘¡ ) we reject the sample with probability ğœ‚ ğ‘Ÿ ğ‘¡ (1 âˆ’

ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ğ‘™ ğ‘¡ )/ ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ğ‘™ ğ‘¡ )) and sample Ëœğ‘¥ ğ‘™ ğ‘¡ again from an adjusted distribu-tion Ëœğ’‘ ğ‘™ ğ‘¡ = norm (max (0, ğ’‘ ğ‘Ÿ ğ‘¡ âˆ’ ğ’‘ ğ‘™ ğ‘¡ )) .

â€¢ Keep the draft token ğ‘¥ ğ‘Ÿ ğ‘¡ as Ëœğ‘¥ ğ‘Ÿ ğ‘¡ if ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ğ‘Ÿ ğ‘¡ ) â‰¤ ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ğ‘Ÿ ğ‘¡ ), and in case 

ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ğ‘Ÿ ğ‘¡ ) > ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ğ‘Ÿ ğ‘¡ ) we reject the sample with probability ğœ‚ ğ‘™ ğ‘¡ (1 âˆ’

ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ğ‘Ÿ ğ‘¡ )/ ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ğ‘Ÿ ğ‘¡ )) and sample Ëœğ‘¥ ğ‘Ÿ ğ‘¡ again from an adjusted distribu-tion Ëœğ’‘ ğ‘Ÿ ğ‘¡ = norm (max (0, ğ’‘ ğ‘™ ğ‘¡ âˆ’ ğ’‘ ğ‘Ÿ ğ‘¡ )) .

> 3We adopt the log-sum-exp trick to maintain numerical stability (See Appendix A.1).

Algorithm 1: SpeculativeAggregation 

Input: Draft tokens ğ‘¥ ğ‘  ğ‘¡ , locally-aggregated distributions ğ’‘ ğ‘  ğ‘¡ ,and aggregation weights â„ğ‘  ğ‘¡ , for ğ‘  âˆˆ { ğ‘™, ğ‘Ÿ }

Output: Target token ğ‘¥ ğ‘¡ , acceptance status Sğ‘™ and Sğ‘Ÿ 

Function Sample( ğ‘¥ , ğ’‘ ğ‘ , ğ’‘ ğ‘ , ğœ‚ ):

Ëœğ‘¥ â† ğ‘¥ , ğœ ğ‘ âˆ¼ ğ‘ˆ (0, 1);

if ğ’‘ ğ‘ (ğ‘¥ ) > ğ’‘ ğ‘ (ğ‘¥ ), ğœ ğ‘ < ğœ‚ (1 âˆ’ ğ’‘ ğ‘ (ğ‘¥ )   

> ğ’‘ ğ‘ (ğ‘¥ )

) then 

Ëœğ‘¥ âˆ¼ norm (max (0, ğ’‘ ğ‘ âˆ’ ğ’‘ ğ‘ )) ;

return Ëœğ‘¥ ;

ğœ‚ ğ‘™ ğ‘¡ â† â„ğ‘™ ğ‘¡ /( â„ğ‘™ ğ‘¡ + â„ğ‘Ÿ ğ‘¡ ), ğœ‚ ğ‘Ÿ ğ‘¡ â† 1 âˆ’ ğœ‚ ğ‘™ ğ‘¡ ;

Ëœğ‘¥ ğ‘™ ğ‘¡ â† Sample (ğ‘¥ ğ‘™ ğ‘¡ , ğ’‘ ğ‘™ ğ‘¡ , ğ’‘ ğ‘Ÿ ğ‘¡ , ğœ‚ ğ‘Ÿ ğ‘¡ ), Ëœğ‘¥ ğ‘Ÿ ğ‘¡ â† Sample (ğ‘¥ ğ‘Ÿ ğ‘¡ , ğ’‘ ğ‘Ÿ ğ‘¡ , ğ’‘ ğ‘™ ğ‘¡ , ğœ‚ ğ‘™ ğ‘¡ );

ğœ âˆ¼ ğ‘ˆ (0, 1), ğ‘¥ ğ‘¡ â† Ëœğ‘¥ ğ‘™ ğ‘¡ Â· 1ğœ â‰¤0.5 + Ëœğ‘¥ ğ‘Ÿ ğ‘¡ Â· 1ğœ >0.5;

Sğ‘™ â† ğ‘¥ ğ‘™ ğ‘¡ = ğ‘¥ ğ‘¡ , Sğ‘Ÿ â† ğ‘¥ ğ‘Ÿ ğ‘¡ = ğ‘¥ ğ‘¡ ;

return ğ‘¥ ğ‘¡ , Sğ‘™ , Sğ‘Ÿ ;It is straightforward to show 4 that through these sampling pro-cesses, both Ëœğ‘¥ ğ‘™ ğ‘¡ and Ëœğ‘¥ ğ‘Ÿ ğ‘¡ are indeed drawn from the aggregated dis-tribution ğœ‚ ğ‘™ ğ‘¡ ğ’‘ ğ‘™ ğ‘¡ + ğœ‚ ğ‘Ÿ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ . We select either Ëœğ‘¥ ğ‘™ ğ‘¡ or Ëœğ‘¥ ğ‘Ÿ ğ‘¡ as ğ‘¥ ğ‘¡ with uniform probability, ensuring ğ‘¥ ğ‘¡ âˆ¼ ğ’‘ ğ‘¡ . Finally, each draft token ğ‘¥ ğ‘™ ğ‘¡ and ğ‘¥ ğ‘Ÿ ğ‘¡ 

is accepted if it matches the target token ğ‘¥ ğ‘¡ ; otherwise, it is re-jected. The aggregation strategy at each step ğ‘¡ is summarized in Algorithm 1. It is worth noting that we design a sampling-based method rather than simply selecting between ğ‘¥ ğ‘™ ğ‘¡ and ğ‘¥ ğ‘Ÿ ğ‘¡ , in order to ensure that ğ‘¥ ğ‘¡ âˆ¼ ğ’‘ ğ‘¡ holds. A counterexample for binary selection is illustrated in cases where arg max ğ’‘ ğ‘¡ differs from both arg max ğ’‘ ğ‘™ ğ‘¡ 

and arg max ğ’‘ ğ‘Ÿ ğ‘¡ .We now present a general procedure for sampling multiple con-secutive tokens. At each step ğ‘¡ , the following workflow is executed: 1) The Aggregator waits until both Draft Queues are non-empty, then fetches ğ‘¥ ğ‘  ğ‘¡ from the front of the local Draft Queues and retrieves the auxiliary variables ğ’‘ ğ‘  ğ‘¡ and â„ğ‘  ğ‘¡ from the local cache, for each ğ‘  âˆˆ { ğ‘™, ğ‘Ÿ }.2) The Aggregator performs aggregation as defined in Algorithm 1. The outputs, including the target token ğ‘¥ ğ‘¡ and the acceptance status of each draft token, are broadcast to notify both sides. 3) Upon receiving the message, each side checks the acceptance status of both ğ‘¥ ğ‘™ ğ‘¡ and ğ‘¥ ğ‘Ÿ ğ‘¡ . If a token is accepted, it is dequeued from the corresponding Draft Queue and step 5) is executed; otherwise, step 4) is executed. 4) If ğ‘¥ ğ‘  ğ‘¡ is rejected, its corresponding Draft Queues on both sides are cleared and the side ğ‘  rolls back its KV cache and re-computes the next draft token ğ‘¥ ğ‘  ğ‘¡ +1 using the target token ğ‘¥ ğ‘¡ as input. 5) Update step ğ‘¡ â† ğ‘¡ + 1, and go back to step 1). We adopt a pipeline approach rather than performing aggrega-tion in parallel. In centralized Speculative Decoding , each execution of the target LLM requires waiting for the draft model to generate the current token and for the LLM to verify the previously gener-ated one. By verifying consecutive tokens in parallel, multiple LLM inferences can be merged into a single pass, shifting the primary latency bottleneck from target LLM inference to the sequential decoding of draft tokens. Conversely, in Speculative Aggregation for 

> 4The proof is included in Appendix A.2.

4distributed RAG, the time to the next token is dominated by data transmission over the network. Consecutive transmission of small data can be naturally overlapped since each transmission does not significantly occupy the I/O for an extended period. Parallelizing the aggregation process instead introduces waiting between draft tokens until the batch is fully populated. We employ queues to construct a pipeline, where each draft token is transmitted and enqueued immediately upon generation, ensuring it is verified at the earliest opportunity. 

## 4.3 Analysis of Acceptance Rate 

We now analyze the factors that influence the acceptance rate of draft tokens on both the device and the cloud sides. 

Definition 4.1. For ğ‘  âˆˆ { ğ‘™, ğ‘Ÿ }, the acceptance rate ğ›½ ğ‘  ğ‘¡ , is the prob-ability of accepting ğ‘¥ ğ‘  ğ‘¡ âˆ¼ ğ’‘ ğ‘  ğ‘¡ = Ãğ‘‘ âˆˆğ· ğ‘  ğœ” ğ‘¡ (ğ‘‘ )ğ’‘ (ğ‘¥ ğ‘¡ |ğ‘‘, ğ‘¥ <ğ‘¡ ) by the aggregation strategy, given a prefix ğ‘¥ <ğ‘¡ .First, we consider the side ğ‘™ as an example. The acceptance of the draft token ğ‘¥ ğ‘™ ğ‘¡ , sampled from ğ’‘ ğ‘™ ğ‘¡ by the Decoder, can be classified into two cases: i) it is accepted during the speculative sampling of Ëœğ‘¥ ğ‘™ ğ‘¡ and ii) it is output by the speculative sampling of Ëœğ‘¥ ğ‘Ÿ ğ‘¡ , where either ğ‘¥ ğ‘Ÿ ğ‘¡ = ğ‘¥ ğ‘™ ğ‘¡ and is accepted, or ğ‘¥ ğ‘™ ğ‘¡ âˆ¼ Ëœğ’‘ ğ‘Ÿ ğ‘¡ . Let ğ›¾ ğ‘™ 

and ğ›¾ ğ‘Ÿ represent the weights assigned to Ëœğ‘¥ ğ‘™ ğ‘¡ and Ëœğ‘¥ ğ‘Ÿ ğ‘¡ in the ran-dom selection following these sampling processes ( ğ›¾ ğ‘™ + ğ›¾ ğ‘Ÿ = 1). We adopt the definition of divergence from [ 33 ], given by ğ›¿ =

ğ· ğ¿ğ¾ (ğ’‘ ğ‘™ ğ‘¡ , ğ’‘ ğ‘Ÿ ğ‘¡ ) = 1âˆ’Ãğ‘¥ min (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ), ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ )) . The expected acceptance rate ğ›¼ ğ‘™ ğ‘¡ = Eğ‘¥ âˆ¼ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ) (ğ›½ ğ‘™ ğ‘¡ ) is computed as 

ğ›¼ ğ‘™ ğ‘¡ = ğ›¾ ğ‘™ (1 âˆ’ ğœ‚ ğ‘Ÿ ğ‘¡ ğ›¿ ) + ğ›¾ ğ‘Ÿ âˆ‘ï¸ ğ‘¥ ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ )ğ’‘ ğ‘¡ (ğ‘¥ ), (5) where the two terms represent the acceptance probability of the two cases above, respectively. These terms are mutually-exclusive and influenced by the mixture weights ğ›¾ ğ‘™ and ğ›¾ ğ‘Ÿ .

Theorem 4.2. Given any distributions ğ’‘ ğ‘™ ğ‘¡ and ğ’‘ ğ‘Ÿ ğ‘¡ , when ğœ‚ ğ‘Ÿ ğ‘¡ is fixed, maximizing ğ›¼ ğ‘™ ğ‘¡ is equivalent to maximizing ğ›¾ ğ‘™ .Proof . Substituting ğ’‘ ğ‘¡ = ğœ‚ ğ‘™ ğ‘¡ ğ’‘ ğ‘™ ğ‘¡ + ğœ‚ ğ‘Ÿ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ 5 and subtracting the two terms in Equation (5) yields (1 âˆ’ ğœ‚ ğ‘Ÿ ğ‘¡ ğ›¿ ) âˆ’ Ã ğ’‘ ğ‘™ ğ‘¡ ğ’‘ ğ‘¡ = ğœ‚ ğ‘™ ğ‘¡ (1 âˆ’ Ã(ğ‘ ğ‘™ ğ‘¡ )2) + 

ğœ‚ ğ‘Ÿ ğ‘¡ 

Ã(min (ğ’‘ ğ‘™ ğ‘¡ , ğ’‘ ğ‘Ÿ ğ‘¡ ) âˆ’ ğ’‘ ğ‘™ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ ). Since 1 > Ãğ‘¥ (ğ’‘ ğ‘™ ğ‘¡ )2, min (ğ’‘ ğ‘™ ğ‘¡ , ğ’‘ ğ‘Ÿ ğ‘¡ ) â‰¥

ğ’‘ ğ‘™ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ and 0 â‰¤ ğœ‚ ğ‘™ ğ‘¡ , ğœ‚ ğ‘Ÿ ğ‘¡ â‰¤ 1, it follows that 1 âˆ’ ğœ‚ ğ‘Ÿ ğ‘¡ ğ›¿ â‰¥ Ã ğ’‘ ğ‘™ ğ‘¡ ğ’‘ ğ‘¡ al-ways holds, with equality holding only when ğœ‚ ğ‘™ ğ‘¡ = 0, ğœ‚ ğ‘Ÿ ğ‘¡ = 1 and 

ğ›¿ = 0. This condition implies that the two distributions ğ’‘ ğ‘™ ğ‘¡ and ğ’‘ ğ‘Ÿ ğ‘¡ 

are completely disjoint. Consequently, maximizing ğ›¾ ğ‘™ leads to the maximization of the expected acceptance rate ğ›¼ ğ‘™ ğ‘¡ . â–¡

For the side ğ‘Ÿ , Theorem 4.2 holds symmetrically, where maximiz-ing the acceptance of ğ‘¥ ğ‘Ÿ ğ‘¡ corresponds to maximizing ğ›¾ ğ‘Ÿ . Clearly, the objectives on sides ğ‘™ and ğ‘Ÿ conflict with each other. For simplicity in framework design, we adopt ğ›¾ ğ‘™ = ğ›¾ ğ‘Ÿ = 0.5 to strike a balance (as shown in Algorithm 1). The expected acceptance rate is then influenced by the degree of overlap between the draft distributions on the two sides. When the distributions ğ’‘ ğ‘™ ğ‘¡ and ğ’‘ ğ‘Ÿ ğ‘¡ perfectly coincide, i.e., the divergence   

> 5For brevity, the variable ğ‘¥ is omitted in the distribution notation throughout the following proof.

ğ‘¥ ğ‘™ ğ‘¡ âˆ’1 ğ‘¥ ğ‘Ÿ ğ‘¡ âˆ’1 Waiting Time for ğ‘¥ ğ‘™ ğ‘¡ and ğ‘¥ ğ‘Ÿ ğ‘¡ 

rejected accepted max (ğ‘ ğ‘™ 

> dec

, ğœ‘ (ğ‘ ğ‘Ÿ  

> dec

+ ğ‘ ğ‘Ÿ 

> trans

)) 

accepted rejected max (ğœ‘ (ğ‘ ğ‘™ 

> dec

), ğ‘ ğ‘™  

> trans

+ ğ‘ ğ‘Ÿ  

> dec

+ ğ‘ ğ‘Ÿ 

> trans

)

accepted accepted max (ğœ‘ (ğ‘ ğ‘™ 

> dec

), ğœ‘ (ğ‘ ğ‘Ÿ  

> dec

+ ğ‘ ğ‘Ÿ 

> trans

)) 

rejected rejected max (ğ‘ ğ‘™ 

> dec

, ğ‘ ğ‘™  

> trans

+ ğ‘ ğ‘Ÿ  

> trans

+ ğ‘ ğ‘Ÿ 

> dec

)

Table 1: Waiting time for the next pair of draft tokens ğ‘¥ ğ‘™ ğ‘¡ and 

ğ‘¥ ğ‘Ÿ ğ‘¡ under different acceptance scenarios of the previous draft tokens ğ‘¥ ğ‘™ ğ‘¡ âˆ’1 and ğ‘¥ ğ‘Ÿ ğ‘¡ âˆ’1.

ğ›¿ becomes zero, the first term of Equation (5) , 1 âˆ’ ğœ‚ ğ‘Ÿ ğ‘¡ ğ›¿ , reaches its maximum value. Simultaneously, since the second term follows âˆ‘ï¸  

> ğ‘¥

ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ )ğ’‘ ğ‘¡ (ğ‘¥ ) â‰¤ âˆšï¸ƒâˆ‘ï¸ ğ‘¥ ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ )2âˆ‘ï¸ ğ‘¥ ğ’‘ ğ‘¡ (ğ‘¥ )2,

based on the Cauchy-Schwarz inequality and achieves its maximum when ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ) = ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ) = ğ’‘ ğ‘¡ (ğ‘¥ ), the expected acceptance rate is max-imized. Conversely, when the support sets of the two distributions are completely disjoint, i.e., ğ›¿ = 1, the product ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ )ğ’‘ ğ‘¡ (ğ‘¥ ) becomes zero for every ğ‘¥ , resulting in a minimized expected acceptance rate. This characteristic provides insight into the principle behind 

Speculative Aggregation : we assume that the device-side and cloud-side RAG workflows generate similar results by default, allowing them to asynchronously decode the next tokens without aggrega-tion. Only when they disagree with each other, the acceptance is adjusted by their aggregation weights ğœ‚ ğ‘™ ğ‘¡ and ğœ‚ ğ‘Ÿ ğ‘¡ .

## 5 Greedy Scheduling 

To further minimize the latency ğ¶ (ğ´ ğ‘¡ , F ) in Equation (3) , We adap-tively schedule which side performs the next aggregation after the current one is completed. The principle behind this is to maximize the overlap between the device-side and cloud-side decoding and transmission processes, jointly considering dynamic computing resources, network bandwidth, and acceptance of draft tokens. 

## 5.1 Scheduling Strategy 

Since predicting future acceptance is challenging due to dynamic document relevance and LLM outputs, we employ a greedy strategy, where at each step, we minimize the expected latency per token based on current observations. The latency per token, denoted as ğ‘ ğ‘¡ , is computed as the average duration between two consecutive aggregations. It can be viewed as the waiting time for the next pair of draft tokens, ğ‘¥ device  

> ğ‘¡

and 

ğ‘¥ cloud  

> ğ‘¡

, including both decoding and transmission delays, as the ag-gregation duration is negligible. For each side ğ‘  âˆˆ { device , cloud },let ğ‘ ğ‘   

> dec

denote the decoding delay of a draft token ğ‘¥ ğ‘  ğ‘¡ , and ğ‘ ğ‘   

> trans

de-note the transmission delay of this token and its auxiliary variables from ğ‘  to the other side. Since the decoding and transmission pro-cesses are asynchronous, they may still be ongoing when the sched-uling algorithm is executed. Therefore, we define ğœ‘ (ğ‘‡ total (ğ‘¢ )) =

max (0,ğ‘‡ total (ğ‘¢ ) + ğ‘‡ begin (ğ‘¢ ) âˆ’ ğ‘‡ now ) as a function that estimates the remaining time of the total duration ğ‘‡ total to complete the process 

ğ‘¢ , where ğ‘‡ begin and ğ‘‡ now are the beginning and current timestamps, respectively. Let ğ‘™ be the side that currently performs aggregation and ğ‘Ÿ be the other one. The best side is then selected as 

ğ‘  âˆ— = arg min ğ‘  âˆˆ { ğ‘™,ğ‘Ÿ } ğ‘ ğ‘  ğ‘¡ (ğœ‘, ğ‘ ğ‘™ ğ‘‘ğ‘’ğ‘ , ğ‘ ğ‘™ ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘  , ğ‘ ğ‘Ÿ ğ‘‘ğ‘’ğ‘ , ğ‘ ğ‘Ÿ ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘  ), (6) 5cr 

> dec

(cl 

> trans

+ cr

> trans

) cr 

> dec

cr 

> dec

+ ( cl 

> trans

+ cr

> trans

)

Local Decoding Latency per Token 

0

> Latency Difference

l-side is better 

r-side is better 

slope = 1 lt

slope = 1 rt           

> lt= 0.5, rt= 0.8 lt= 0.8, rt= 0.5 lt= 0.5, rt= 0.5

Figure 3: Difference in per-token latencies when side ğ‘™ and ğ‘Ÿ 

performs aggregation, versus varying ğ‘™ -side decoding latency. 

where ğ‘ ğ‘  ğ‘¡ denotes the latency per token when ğ‘  continuously per-forms the aggregations in the future. Next, we present the calculation of ğ‘ ğ‘  ğ‘¡ . Table 1 illustrates the waiting time for the next pair of draft tokens after a previous aggre-gation. To estimate an averaged ğ‘ ğ‘  ğ‘¡ over multiple future steps, rather than enumerating all possible combinations of acceptance scenar-ios, we assume each acceptance scenario repeats continuously 6 and occurs with an expected probability given by the acceptance rate. Therefore, the waiting time in Table 1 can be simplified to eliminate the function ğœ‘ . First, assuming that draft tokens from ğ‘Ÿ are always accepted, the decoding process for consecutive draft tokens will be continuous on ğ‘Ÿ . In other words, the decoding of ğ‘¥ ğ‘Ÿ ğ‘¡ begins exactly when ğ‘¥ ğ‘Ÿ ğ‘¡ âˆ’1 is decoded and ready for transmission. Therefore, we have ğœ‘ (ğ‘ ğ‘Ÿ  

> dec

+ğ‘ ğ‘Ÿ 

> trans

) = (ğ‘‡ begin +ğ‘ ğ‘Ÿ  

> trans

âˆ’ğ‘‡ now )+ ğ‘ ğ‘Ÿ  

> dec

= ğ‘ ğ‘Ÿ 

> dec

. Moreover, since the aggregation process can exhaustively consume the token pairs in the Draft Queues, ğœ‘ (ğ‘ ğ‘™ 

> dec

) < ğ‘ ğ‘™  

> dec

holds only when the wait-ing time for ğ‘¥ ğ‘Ÿ ğ‘¡ dominates. Hence, max (ğœ‘ (ğ‘ ğ‘™ 

> dec

), Â·) = max (ğ‘ ğ‘™ 

> dec

, Â·) .Finally, ğ‘ ğ‘™ ğ‘¡ is calculated as 

ğ›¼ ğ‘Ÿ ğ‘¡ max (ğ‘ ğ‘™ 

> dec

, ğ‘ ğ‘Ÿ 

> dec

) + ( 1 âˆ’ ğ›¼ ğ‘Ÿ ğ‘¡ ) max (ğ‘ ğ‘™ 

> dec

, ğ‘ ğ‘Ÿ  

> dec

+ ğ‘ ğ‘™  

> trans

+ ğ‘ ğ‘™ 

> trans

). (7) Symmetrically, ğ‘ ğ‘Ÿ ğ‘¡ is computed by exchanging ğ‘™ and ğ‘Ÿ in Equa-tion (7) . Based on this, we can conclude that when the local de-coding latency ğ‘ ğ‘™  

> dec

cannot cover the waiting time for draft tokens from the other side, i.e., ğ‘ ğ‘™  

> dec

< ğ‘ ğ‘Ÿ  

> dec

+ ğ‘ ğ‘™  

> trans

+ ğ‘ ğ‘™ 

> trans

, minimizing the overall latency ğ‘ ğ‘™ ğ‘¡ requires maximizing the acceptance rate ğ›¼ ğ‘Ÿ ğ‘¡ .To decide the optimal side in Equation (6) , we calculate the differ-ence in latencies per token when side ğ‘™ and ğ‘Ÿ performs aggregation. The result is presented as a piecewise function, 

Î”ğ‘ ğ‘¡ =

ï£±ï£´ï£´ï£´ï£´ï£´ï£²ï£´ï£´ï£´ï£´ï£´ï£³

(1 âˆ’ ğ›¼ ğ‘Ÿ ğ‘¡ )rtt , ğ‘ ğ‘™  

> dec

â‰¤ ğ‘ ğ‘Ÿ  

> dec

âˆ’ rtt 

(1 âˆ’ ğ›¼ ğ‘™ ğ‘¡ ) ğ‘— + ( ğ›¼ ğ‘™ ğ‘¡ âˆ’ ğ›¼ ğ‘Ÿ ğ‘¡ )rtt , ğ‘ ğ‘Ÿ  

> dec

âˆ’ rtt < ğ‘ ğ‘™  

> dec

â‰¤ ğ‘ ğ‘Ÿ 

> dec

(1 âˆ’ ğ›¼ ğ‘Ÿ ğ‘¡ ) ğ‘— + ( ğ›¼ ğ‘™ ğ‘¡ âˆ’ ğ›¼ ğ‘Ÿ ğ‘¡ )rtt , ğ‘ ğ‘Ÿ  

> dec

< ğ‘ ğ‘™  

> dec

â‰¤ ğ‘ ğ‘Ÿ  

> dec

+ rtt 

(ğ‘ ğ‘™ ğ‘¡ âˆ’ 1)rtt , ğ‘ ğ‘Ÿ  

> dec

+ rtt < ğ‘ ğ‘™ 

> dec

, (8) where rtt = ğ‘ ğ‘™  

> trans

+ ğ‘ ğ‘Ÿ 

> trans

, and ğ‘— is the difference in decoding la-tencies, ğ‘ ğ‘Ÿ  

> dec

âˆ’ ğ‘ ğ‘™ 

> dec

. Accordingly, we select side ğ‘Ÿ for aggregation when Î”ğ‘ ğ‘¡ > 0, and side ğ‘™ otherwise. Figure 3 shows the influence of varying acceptance rates on Î”ğ‘ ğ‘¡ . As the acceptance rate of draft tokens from one side increases, the Scheduler tends to favor the opposite side. Moreover, the relationship between ğ‘ ğ‘™  

> dec

and ğ‘ ğ‘Ÿ  

> dec

also influences the strategy. For instance, when the decoding process on one side becomes the latency bottleneck, aggregation is always performed on that side, which is demonstrated by (1 âˆ’ ğ›¼ ğ‘Ÿ ğ‘¡ )rtt â‰¥ 0

and (ğ›¼ ğ‘™ ğ‘¡ âˆ’ 1)rtt â‰¤ 0. Clearly, our strategy minimizes the likelihood 

> 6Please refer to Appendix A.3 for pipeline illustrations of different cases.

of repeated bottleneck decoding due to rejection, while maximiz-ing the overlap between the decoding and transmission processes across the two sides. 

## 5.2 Profiling 

The Profiler helps estimate a set of parameters required to compute Equation (6) , including the decoding delay ( ğ‘ dec ) on both the device and cloud sides, the transmission delay ( ğ‘ device trans + ğ‘ cloud trans ) between them, and the acceptance rates ( ğ›¼ ). The Profiler operates in two stages: i) offline and ii) runtime. 

Offline stage. For each side ğ‘  âˆˆ { device , cloud }, the Profiler mea-sures the decoding delay by simulating the output-aggregation RAG workflow locally. We randomly generate |ğ· ğ‘  | dummy text chunks as retrieved documents with the same chunk size ğ‘€ as in the real corpus. We use the dummy text directly as the prefix (without a query prompt) and prefill its KV cache in advance. Next, we perform auto-regressive decoding with the same batch size as during run-time, until the context length reaches its maximum ğ‘ . We record the decoding delay ğ‘ ğ‘   

> dec

(ğ‘¡ ) at each step ğ‘¡ = ğ‘€, . . . , ğ‘ âˆ’ 1 by averag-ing over multiple runs and fit the records ğ’„ ğ‘   

> dec

= ğ‘ ğ‘   

> dec

(ğ‘¡ )  

> ğ‘¡ âˆˆğ’•

using a least square errors (LSE) estimator, Ë†ğ‘ ğ‘   

> dec

= ğ‘˜ ğ‘  ğ‘ ğ‘¡ /ğ‘˜ ğ‘  ğ‘ + ğ‘˜ ğ‘  ğ‘ , where the coefficients ğ‘˜ ğ‘  ğ‘ , ğ‘˜ ğ‘  ğ‘ , and ğ‘˜ ğ‘  ğ‘ are synchronized across both sides. We model the transmission delay as Ë†ğ‘ ğ‘   

> trans

(ğ‘” ) = ğ¿ ğ‘  +ğ‘” /ğµ ğ‘  , where 

ğ‘” represents the data size and ğ¿ ğ‘  and ğµ ğ‘  correspond to the network latency and bandwidth for transmitting data from ğ‘  to the other side. Since one-way delay is hardly measurable, we measure the bi-directional delay Ë†ğ‘ device trans + Ë†ğ‘ cloud trans altogether. We utilize sockperf 

to evaluate the round trip time ğ¿ device + ğ¿ cloud and use iperf3 to measure the bi-directional bandwidths. 

Runtime stage. To assess decoding latency at runtime, the Decoder on each side ğ‘  âˆˆ { device , cloud } measures the duration Ëœğ‘ ğ‘   

> dec

(ğ‘¡ ) of decoding a draft token at step ğ‘¡ using the time.perf_counter function in Python. This measurement is then piggybacked onto the draft token message for convenient synchronization. Next, the value of Ë†ğ‘ ğ‘   

> dec

is re-estimated with the intercept ğ‘˜ ğ‘  ğ‘ frozen and the slope updated as 

(1 âˆ’ ğœ )ğ‘˜ ğ‘  ğ‘ + ğœ ( Ëœğ‘ ğ‘   

> dec

(ğ‘¡ ) âˆ’ ğ‘˜ ğ‘  ğ‘ )ğ‘¡ 

(1 âˆ’ ğœ )ğ‘˜ ğ‘  ğ‘ + ğœ ğ‘¡ 2 ,

where ğœ is the weight on new observation. The estimation of trans-mission delay is refined by means of two moving averages: a real-time estimate and a historical moving average. For the former, we update the round-trip time measurement ğ¿ device + ğ¿ cloud at each step ğ‘¡ using the ICMP-based network diagnostic tool, ping . In con-trast, the sending and receiving bandwidth ğµ ğ‘  are updated using 

iperf3 every few tokens to avoid excessive overhead. Similarly, we estimate acceptance rates using Equation 5 and apply a moving average to prevent abrupt changes. 

## 6 Theoretical Wall-Time Improvement 

In this section, we present a theoretical analysis to demonstrate the improvement in wall-time efficiency achieved by DRAGON over the vanilla distributed RAG framework described in Â§ 2.2. Specifically, the synchronized aggregation strategy used in the vanilla RAG can be viewed as a special case of speculative aggregation in which draft tokens from both sides are consistently rejected. To facilitate 610 30 50 70 90           

> Decoding Latency cldec (ms)
> 1.0
> 1.2
> 1.4
> 1.6
> 1.8
> 2.0
> Speedup
> rt= 0.50
> 10 30 50 70 90
> Decoding Latency cldec (ms)
> 5
> 10
> 15
> 20
> 25
> 1
> rt= 0.99
> crdec =10 ms, rtt=100 ms
> crdec =10 ms, rtt=300 ms
> crdec =30 ms, rtt=100 ms
> crdec =30 ms, rtt=300 ms

Figure 4: Theoretical speedup of DRAGON compared to the vanilla distributed RAG vs. varying ğ‘ ğ‘™ 

> dec

, ğ‘ ğ‘Ÿ 

> dec

, rtt and ğ›¼ ğ‘Ÿ ğ‘¡ .

analysis, we assume the aggregation is always performed on the device in following discussions. 

Definition 6.1. Let ğ‘ ğ‘¡ and Ëœğ‘ ğ‘¡ be the expected per-token latencies at step ğ‘¡ when using DRAGON and the vanilla distributed RAG, respectively. Define the speedup as ğ‘† ğ‘¡ = Ëœğ‘ ğ‘¡ /ğ‘ ğ‘¡ .

Theorem 6.2. Given ğ‘™ = device and ğ‘Ÿ = cloud , the speedup can be described as a piecewise function dependent on the relationship among ğ‘ ğ‘™ 

> dec

, ğ‘ ğ‘Ÿ  

> dec

and rtt, as follows: 

1

ğ‘† ğ‘¡ 

=

ï£±ï£´ï£´ï£´ï£´ï£´ï£²ï£´ï£´ï£´ï£´ï£´ï£³

1 âˆ’ ğ›¼ ğ‘Ÿ ğ‘¡  

> 1+ğ‘ ğ‘Ÿ
> dec /rtt

, ğ‘ ğ‘™  

> dec

â‰¤ ğ‘ ğ‘Ÿ 

> dec

1 âˆ’ ( 1 âˆ’ ğ‘ ğ‘™   

> dec
> ğ‘ ğ‘Ÿ ğ‘‘ğ‘’ğ‘ +rtt

)ğ›¼ ğ‘Ÿ ğ‘¡ , ğ‘ ğ‘Ÿ  

> dec

< ğ‘ ğ‘™  

> dec

â‰¤ ğ‘ ğ‘Ÿ  

> dec

+ rtt 

1, ğ‘ ğ‘Ÿ  

> dec

+ rtt < ğ‘ ğ‘™ 

> dec

(9) 

Proof . ğ‘ ğ‘¡ is computed according to Equation (7) . By substituting 

ğ›¼ ğ‘™ ğ‘¡ = ğ›¼ ğ‘Ÿ ğ‘¡ = 0 and we obtain Ëœğ‘ ğ‘¡ = max (ğ‘ ğ‘™ 

> dec

, ğ‘ ğ‘Ÿ  

> dec

+ rtt ). The result then follows from a simple case-by-case analysis. â–¡

Figure 4 illustrates the theoretical speedup characterized in The-orem 6.2. The speedup achieves its maximum when the device-side decoding latency is minimal and maintains saturated until it sur-passes that of the cloud. Thereafter, the speedup decreases inversely with ğ‘ ğ‘™ 

> dec

, gradually approaching 1 and eventually stabilizing at 1 once ğ‘ ğ‘™  

> dec

exceeds ğ‘ ğ‘Ÿ  

> dec

+ rtt . Finally, we have following corollaries: 

Corollary 6.3. DRAGON is particularly effective when the decod-ing latency gap between the device and the cloud is small and the transmission cost becomes the primary bottleneck. 

This property broadens the potential application of DRAGON to general scenarios in which distributed computing nodes have com-parable computational resources, but communication remains a key bottleneck requiring further optimization. 

Corollary 6.4. DRAGONâ€™s improvement in wall time can be sub-stantially amplified when the cloud-side acceptance rate is high. 

Numerous existing works [ 18 , 63 ] have shown that a small subset of tokens receives the majority of attention and replacing them significantly changes the output sequence [ 37 ]. Accordingly, we argue that draft tokens that differ from those on the other side pri-marily originate from this subset and are synchronized across both sides. In contrast, other tokens (such as stop words, punctuations and common-knowledge terms) are often context-independent and shared across both sides, leading to a considerable acceptance rate. 

Corollary 6.5. DRAGONâ€™s improvement in wall time is independent of the device-side acceptance rate. 

When the device-side decoding latency is much lower, the Aggre-gator must wait for the arrival of cloud-side draft tokens before generating the next target token, regardless of whether the device-side draft is accepted. Similarly, when the device-side latency is substantially higher, the next target token is generated immediately and fed as input for the next decoding step after completing the current one. As a result, the acceptance of the local draft has no impact on the overall latency. However, it remains important when aggregation is shifted to the other side via DRAGONâ€™s scheduling algorithm. 

## 7 Experiments 7.1 Implementation 

We implemented DRAGON for distributed RAG workflow compris-ing ~3,000 lines of Python code. 7 The System consists of two sym-metric processes, the device-side and cloud-side ones, each utilizing eight threads for core functionalities (e.g., decoding, aggregation and transmission) along with a memory-resident service process for document retrieval. We implemented information synchroniza-tion between threads using multi-producer, multi-consumer queues, and between processes using socket-based communication. We uti-lized PyTorch [ 44 ] (version 2.6.0) for algorithm implementations, 

Hugging Face Transformers [ 54 ] for LLM utilities, LangChain [31 ]for document chunking, Sentence Transformers [48 ] for document re-ranking, and Faiss [ 26 ] for indexing and similarity search of document embeddings. 

Efficient transmission. We implemented data transmission over the TCP/IP protocol using the socket library. A fixed-length mes-sage header is defined using the struct module, containing the message type and body size. All Python objects in the message body are finally serialized using the pickle.dumps() function and compressed by means of an LZ4 compressor, while numeric vec-tors are first serialized with numpy.tobytes() . For transmitting the output distributions ğ’‘ device  

> ğ‘¡

and ğ’‘ cloud  

> ğ‘¡

, we employ an aggressive top-ğ‘ selection strategy [ 16 ] with ğ‘ = 0.8, encoding the selected indices as unsigned 8-bit integers and the values as 16-bit floating-point numbers. While preserving the inference performance, the transmission data size is significantly reducedâ€”by approximately 2,363 times when given the vocabulary size of 50,272â€”compared to the unoptimized JSON-based implementation. 

Preemptible generation. We implemented a hook function that raises an exception upon the occurrence of a stop event (e.g., receiv-ing a draft token rejection message) and registered it in the forward pass of each model layer to enable layer-wise interruption of draft decoding. When the generation caller catches the exception, it rolls back the KV cache and attention masks based on the number of generated target tokens so far and feeds the latest target token as input to trigger re-computation. 

## 7.2 Experiment Setups 

Testbed. We evaluated our framework and baseline methods using a high-performance computer as the cloud server and a MacBook Pro as the edge device. The server is equipped with an Intel Xeon Silver 4210R CPU, 64GB of memory, and a GeForce RTX 3090 GPU, 

> 7Our code is available at GitHub: https://github.com/ThomasAtlantis/DRAGON

7while the MacBook Pro features an Intel Core i7 CPU, 16GB of memory, and no dedicated GPU. The cloud and the device are connected via a 2.4 GHz Wi-Fi local-area network, with latency and jitter measured by sockperf as 2ms and 6ms, respectively. To simulate network jitter, we replay a predefined random latency trace by adjusting the network interface controller (NIC) latency using the traffic control tool, tc .

Datasets and metrics. We evaluated the long-sequence generation performance of DRAGON on the large-scale language modeling dataset WikiText [ 41 ], which comprises over 100 million tokens ex-tracted from verified Good and Featured articles on Wikipedia. We constructed retrieval corpora from the training sets of two different-scale versions, WikiText2 and WikiText103. During evaluation, we applied rolling windows of 1024 and 512 tokens, respectively, over their test sets, using the first 1/8 of each window as the query for retrieval and the remaining tokens for perplexity evaluation. To further assess the efficiency of our method, we measure the time to first token (TTFT) and per-token latency. In this measurement, we used the retrieval corpus and index pre-built by Facebook from a Wikipedia dump dated December 20, 2018, which contains 21 million documents. 

Models and baselines. We evaluated our framework using OPT-1.3B [62] and Qwen2.5-1.5B [57], with vocabulary sizes of 151,936 and 50,272, respectively. For language modeling and latency mea-surement, we adopted Contriever [ 22 ] and DPR [ 29 ] as the retriev-ers, respectively. Additionally, we employed ms-marco-MiniLM-L6-v2 [ 48 ] for document re-ranking. We compare DRAGON with four baseline methods: 

â€¢ CRCG, centralized generation augmented with centralized re-trieval from local corpus, using the context-aggregation strategy, which represents most existing RAG methods [24, 38, 46]. 

â€¢ DRCG, on-device generation augmented with documents re-trieved from a distributed corpus spanning both the device and the cloud, using the context-aggregation strategy. 

â€¢ DRDG/TW, distributed RAG using the output aggregation strat-egy and token-wise synchronization, as discussed in Â§ 2.2. The target tokens are collected and aggregated on the device side. 

â€¢ DRDG/SW, distributed RAG using the output aggregation strat-egy and sequence-wise synchronization, i.e., one-time aggrega-tion of the independently generated output sequences from the device and the cloud. This baseline is implemented by extend-ing the official REPLUG [ 51 ] implementation and Facebookâ€™s RAG-Sequence model [36] with distributed support. To simulate insufficient but complementary corpus in the cloud and device sides, we constrain the on-cloud and on-device retrieval by selecting the first and second halves of the top-k documents from the same corpus, respectively. Moreover, to study the overhead of DRCG, we evaluate two variants: DRCG/Text retrieves raw text and prefill KV cache from scratch and DRCG/KV retrieves and reuses the KV cache of documents directly. 

## 7.3 Overall Performance and Efficiency 

We first present the overall performance and efficiency of DRAGON in comparison to the baselines. In the following experiments, we set the maximum context length to 256 tokens on both the device and cloud sides, with each retrieved document limited to 64 tokens. 0 2 4 6 8 10 12 14 16             

> Number of Retrieved Documents
> 10.2
> 10.4
> 10.6
> 10.8
> Perplexity
> 0246810 12 14 16
> Number of Retrieved Documents
> 14.2
> 14.4
> 14.6
> 14.8
> 15.0
> Perplexity
> w/o Retrieval CRCG/Cloud CRCG/Device DRCG DRAGON

(a) Qwen2.5-1.5B/WikiText2. (b) OPT-1.3B/WikiText103. 

Figure 5: Performance on WikiText. 0 50 100 150 200 250 300           

> Extra Network Latency (ms)
> 0
> 100
> 200
> 300
> 400
> 500
> Latency per Token (ms)
> 050 100 150 200 250 300
> Extra Network Latency (ms)
> 0
> 50
> 100
> 150
> 200
> 250
> 300
> Latency per Token (ms) CRCG/Device CRCG/Cloud DRDG/SW DRDG/TW DRAGON

(a) Qwen2.5-1.5B. (b) OPT-1.3B. 

Figure 6: Per-token latency in various network conditions. 0 50 100 150 200 250 300           

> Extra Network Latency (ms)
> 0
> 4
> 8
> 12
> Time to First Token (s)
> 050 100 150 200 250 300
> Extra Network Latency (ms)
> 0
> 5
> 10
> 15
> 20
> Time to First Token (s) DRCG/Text DRCG/KV DRAGON CRCG/Device CRCG/Cloud

(a) Qwen2.5-1.5B. (b) OPT-1.3B. 

Figure 7: Time-to-First-Token in various network conditions. Performance. We linearly increase the number of retrieved docu-ments on both the device and the cloud sides from 0 to 16 and report the corresponding language modeling perplexity on WikiText. As shown in Figure 5, DRAGON matches or outperforms all baseline methods across all settings. As more documents are integrated, the performance gap between DRAGON and the baseline methods widens. Finally, DRAGON achieves 1.9Ã— and 1.4Ã— improvements over the non-RAG method, compared to the second-best RAG base-lines, for Qwen and OPT, respectively. In contrast, CRCG methods perform poorly due to an insufficient number of retrieved docu-ments, which indicates incomplete knowledge for the given context. Additionally, the performance of DRCG quickly saturates once the amount of retrieved text reaches the context budget limit. How-ever, we observe a gap between DRCG and our method prior to the saturation, suggesting that output aggregation may inherently outperform context aggregation. The results of DRDG methods are omitted, as they produce identical outputs to DRAGON under the language modeling setting. 

Efficiency. We inject additional latency to the serverâ€™s NIC, ranging from 0 to 300 ms, along with a jitter equal to 1/5 of the corresponding latency value. We sample prompts from 10k_prompts_ranked [21], a collection of synthetic and human-generated prompts with asso-ciated ranking, and report the average end-to-end decoding latency 8over 20 output tokens 8. Figure 6 presents the per-token latency when incorporating the top-2 relevant documents for the RAG pro-cess on each side. As shown in the figure, DRAGON demonstrates strong robustness under different network conditions compared to other distributed baseline methods. Specifically, DRAGON achieves latency reduction of 49.5% and 42.4% when using OPT-1.3B com-pared to the sequence-wise and token-wise DRDG methods, re-spectively. In contrast, the per-token latency of DRDG methods fluctuates significantly and tends to increase under higher network latency conditions. Sequence-wise DRDG collects output distribu-tions of all tokens once after generation completes, resulting in a one-time large data transmission and increased sensitivity to network latency. Token-wise DRDG amortizes data transmission over the entire generation process, partially hiding latency within decoding. However, it still under-performs compared to DRAGON due to frequent output synchronizations. Additionally, DRCG meth-ods yields the same per-token latency with corresponding CRCG methods, because they do not involve cooperation between the device and the cloud. Although DRAGON incurs an average la-tency overhead of 15.6%â€“20.3% compared to device-only methods, it effectively supports tasks that require both personal and general knowledge, where device-only or cloud-only methods may fail. We further compare the TTFT of DRAGON with that of the baseline methods under identical network conditions. TTFT typi-cally includes the time for document retrieval and the latency of the prefill stage, during which the key-value (KV) activations for the concatenation of retrieved documents and the input query are either computed from scratch in parallel or loaded from cache. As shown in Figure 7, DRAGON incurs negligible TTFT overhead com-pared to the device-only CRCG method. In contrast, as KV cache is hosted on the same side with the corpus, DRCG/Text performs prefill from scratch, resulting in high computation latency and 8.6Ã—

TTFT on average compared to DRAGON. DRCG/KV directly fetches KV activations from the server, leading to increased transmission time under higher network latency and yielding over 15 .3Ã— TTFT compared to DRAGON, rendering it entirely impractical. Notably, DRCG/Text incurs larger prefill latency when using Qwen2.5-1.5B compared to OPT-1.3B, due to its larger number of parameters. In contrast, DRCG/KV exhibits higher TTFT on OPT-1.3B, as Qwen2.5-1.5B employs Grouped-Query Attention (GQA [ 2 ]) to reduce the size of KV activations. The transmission data size in DRCG/KV is 114 MB for OPT-1.3B and 16 MB for Qwen2.5-1.5B when retrieving 2 documents of 64 tokens each. Latency for local document retrieval is measured at 52.6 ms, while latency for remote raw-text retrieval ranges from 107.2 ms to 745.2 ms as extra network latency increases from 0 to 300 ms. 

## 7.4 Effectiveness of Scheduling 

To thoroughly evaluate the effectiveness of scheduling, we imple-mented a simulator to run DRAGON repeatedly using different scheduling strategies under consistent settings. We compare our scheduling strategy with three baseline methods: (1) Cloud and (2) 

Device , where aggregation is statically performed in the cloud and             

> 8Despite averaging, the results still exhibits fluctuations due to varying CPU load and network jitter, but do not affect the overall conclusion. 0100 200 300 400
> Extra Latency (ms)
> 0
> 10
> 20
> 30
> 40
> Total Time (s)
> 0100 200 300 400
> Extra Latency (ms)
> 0
> 10
> 20
> 30
> 40
> Total Time (s)
> Cloud Random Device DRAGON
> (a) Qwen2.5-1.5B. (b) OPT-1.3B.

Figure 8: Comparison of different scheduling strategies. DRAGON      

> Pipeline
> Cloud
> Decode DraftToken TargetToken SwitchAggregator
> Device
> 0.5
> 0.6
> RTT (s)
> -0.5
> 0.0
> 0.5
> 1.0
> Z Cloud Device
> 0.5
> 1.1
> 1.3
> 1.5
> 1.8
> 2.0
> 2.4
> 2.6
> 2.9
> 3.1
> 3.4
> 3.7
> 4.0
> 4.3
> 4.5  Time (s)
> 0.0
> 0.5
> 1.0
> Acc.
> Cloud Device

Figure 9: A random snapshot of the generation pipeline and scheduling decisions of DRAGON. 

the device, respectively, and (3) Random , which randomly selects the side for aggregation. To implement the simulation, we record and replay the accep-tance decisions of the Aggregator, and use real-world measurements of decoding latency on each side. We simulate varying network conditions by adding an extra latency and a sinusoidal jitter to the measured base latency. The period of the jitter is set to 20 ğœ‹ 

seconds with its amplitude set to 1/5 of the corresponding latency, consistent with the settings in Â§ 7.3. Figure 8 presents the total time required to generate 100 tokens under varying network conditions, each averaged over 50 different acceptance decision sequences. The results show that DRAGONâ€™s scheduling strategy matches or outperforms all baselines across all settings, with the efficiency gains increasing as the extra latency grows. Due to the substantial gap in decoding latencies between the device and the cloud (as shown in Figure 6), performing aggregation on the device naturally hides cloud-side decoding and transmis-sion within device-side decoding. When network latency is low, 

Cloud and Random tend to incur higher latency while DRAGON consistently selects the device side for aggregation. As network latency grows and transmission becomes the bottleneck, DRAGON dynamically selects the side with higher acceptance rate to mini-mize transmission resulted from draft rejection. Finally, we argue that when device-side and cloud-side decoding latencies become closer in value, the overall generation time will be more sensitive to the network latency. In that case, our scheduling strategy will achieve greater improvement compared to these baseline methods. 

Case study. To illustrate DRAGONâ€™s detailed scheduling process, we present a 15-token snapshot of a random simulation with the extra latency set to 500 ms. Figure 9 shows, from top to bottom, 9the cloud-side and device-side generation pipelines, the instanta-neous RTT, the estimation score Î”ğ‘ as defined in Equation (8) , and the accumulated acceptance rates. The pipeline graph comprises vertically arranged bars representing decoding and different trans-mission tasks (including transmission of draft tokens, target tokens and instruction signals for switching aggregation place). Initially, the Aggregator resides on the device by default. From the perspective of the device, ğ‘ ğ‘Ÿ  

> dec

< ğ‘ ğ‘™  

> dec

â‰¤ ğ‘ ğ‘Ÿ  

> dec

+ rtt consistently holds and Î”ğ‘ is computed as the sum of two terms, ğ´ = (1 âˆ’

ğ›¼ ğ‘Ÿ ğ‘¡ )( ğ‘ ğ‘Ÿ 

> dec

âˆ’ğ‘ ğ‘™ 

> dec

) and ğµ = (ğ›¼ ğ‘™ ğ‘¡ âˆ’ğ›¼ ğ‘Ÿ ğ‘¡ )rtt . After the first aggregation at 0.5 s, the acceptance rates are updated to ğ›¼ ğ‘™  

> 0

= 1 and ğ›¼ ğ‘Ÿ  

> 0

= 0. As a result, the positive term ğµ dominates and Î”ğ‘ > 0. The Scheduler decides to switch the Aggregator to the cloud, sending the switching signal along with the target token. It then shifts to the cloudâ€™s perspective and reverses the sign of Î”ğ‘ . Subsequently, since the accumulated cloud-side acceptance rate remains lower, the Scheduler continues to estimating Î”ğ‘ < 0, indicating that cloud-side aggregation is more efficient. This case shows that DRAGONâ€™s scheduling strategy dynamically minimizes decoding and transmission costs on the side with a lower acceptance rate, which is consistent with our analysis in Â§ 5.1 and the results shown in Figure 8. 

## 8 Related Works 

RAG with multiple documents. RAG approaches commonly retrieve multiple documents to improve performance during in-ference [ 3], but the way of aggregating them primarily diverge into two categories: output aggregation and context aggregation 

(Â§ 2.1). For output aggregation, pioneering works [ 15 , 36 ] prior to LLMs have proven its effectiveness for encoder-only and seq2seq models on both extractive [ 15 ] and abstractive [ 36 ] NLP tasks. RE-PLUG [ 51 ] expands this method to off-the-shelf decoder-only LLMs by fine-tuning a dense retriever. CAD [ 50 ] adopts the same idea to strike a balance between retrieval-augmented outputs and LLM-only outputs. RA-CM3 [ 59 ] enables few-shot image classification for multimodal language model by aggregating the predictions given different retrieved examples. Context aggregation prepend the concatenation of all documents to the input and is adopted by a line of in-context RAG methods [ 24 , 38 , 46 ] for simplicity. PCW [ 47 ]eliminates cross-attentions between documents to mitigate the high computational overhead introduced by this architecture. Our frame-work leverages output aggregation to facilitate the decomposition of the multi-document RAG workflow across the device and the cloud, whereas existing works adopt a centralized architecture. 

Device-cloud collaborative inference. To simultaneously achieve privacy preservation and low latency in mobile computing while benefiting from the robust computational power of cloud, numerous studies [ 6, 19 , 28 , 32 , 61 ] have investigated device-cloud collabo-rative inference for conventional neural networks. Recently, this collaborative inference paradigm has been extended to large lan-guage models [ 43 , 45 ]. CE-CoLLM [ 25 ] splits LLMs along depth and offloads deeper layers to the cloud, with a context manager to cache and reuse transmitted intermediate hidden states. Crayon [ 5 ]offloads difficult or non-customized tasks to a more capable cloud-hosted LLM rather than the on-device SLM. However, only a few existing works have explored enhancing on-device RAG with cloud-side knowledge. Hybrid-RACA [ 56 ] implements a real-time compo-sition assistant, in which cloud-side documents are retrieved, com-pressed by an LLM and subsequently downloaded to enhance an on-device SLM. [ 14 ] utilizes userâ€™s historical interactions with the cloud-based LLM to enhance on-device kNN-LMs [ 30 ]. These works prioritize service availability over privacy preservation, retrieving information from a single database processed by LLMs instead of employing inter-model collaborative generation. In contrast, DRAGON adopts a symmetric architecture, leveraging databases on both the device and cloud sides, enabling model collaboration without compromising document privacy. 

Speculative decoding. Speculative decoding, initially proposed in [ 55 ], accelerates the sequential decoding process of LLMs through a draft-then-verify paradigm, where at each decoding step, mul-tiple consecutive future tokens are efficiently drafted by a small LM, and then verified in parallel by the target LLM. Concurrent studies by [ 34 ] and [ 10 ] introduced Speculative Sampling, extend-ing this paradigm to support diverse sampling strategies. These works utilize readily available smaller language models from the same model family as the target LLM for drafting, thus avoiding additional training. Another line of research directly utilizes the target LLM for drafting. Medusa [8] and Blockwise Decoding [53] integrate feed-forward network (FFN) heads into the Transformer decoder, enabling parallel generation of draft tokens per step. Other works [ 17 , 58 , 60 ] have investigated early exiting and layer skip-ping within the target LLM to implement drafting. In contrast to speculative decoding, where a single drafter fast predicts the output of the target LLM, speculative aggregation in DRAGON verifies the consistency between outputs generated by two distinct LLMs. 

## 9 Conclusion 

To address privacy risks of cloud LLMs and limited capabilities of on-device SLMs, we propose DRAGON, a distributed RAG framework that enhances on-device SLMs using both personal and general knowledge without raw document transmission. DRAGON parti-tions the RAG workflow across device and cloud, using Speculative Aggregation to minimize output synchronization overhead. Experi-mental results show that DRAGON notably improves generation quality while maintaining low latency. 

## References                   

> [1] Abdelrahman Abouelenin, Atabak Ashfaq, Adam Atkinson, Hany Awadalla, Nguyen Bach, Jianmin Bao, Alon Benhaim, Martin Cai, Vishrav Chaudhary, Congcong Chen, et al .2025. Phi-4-mini technical report: Compact yet powerful multimodal language models via mixture-of-loras. arXiv:2503.01743 [2] Joshua Ainslie, James Lee-Thorp, Michiel de Jong, Yury Zemlyanskiy, Federico LebrÃ³n, and Sumit Sanghai. 2023. GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints. In EMNLP . 4895â€“4901. [3] Akari Asai, Zexuan Zhong, Danqi Chen, Pang Wei Koh, Luke Zettlemoyer, Han-naneh Hajishirzi, and Wen-tau Yih. 2024. Reliable, adaptable, and attributable language models with retrieval. arXiv preprint arXiv:2403.03187 (2024). [4] AI at Meta. 2024. facebook/wiki_dpr. https://huggingface.co/datasets/facebook/ wiki_dpr. Accessed: 2025-04-01. [5] Jihwan Bang, Juntae Lee, Kyuhong Shim, Seunghan Yang, and Simyung Chang. 2024. Crayon: Customized On-Device LLM via Instant Adapter Blending and Edge-Server Hybrid Inference. In ACL . 3720â€“3731. [6] Amin Banitalebi-Dehkordi, Naveen Vedula, Jian Pei, Fei Xia, Lanjun Wang, and Yong Zhang. 2021. Auto-split: a general framework of collaborative edge-cloud ai. SIGKDD (2021), 2543â€“2553. [7] Sebastian Borgeaud, Arthur Mensch, Jordan Hoffmann, Trevor Cai, Eliza Ruther-ford, et al .2022. Improving language models by retrieving from trillions of

10 tokens. In ICML . 2206â€“2240. [8] Tianle Cai, Yuhong Li, Zhengyang Geng, Hongwu Peng, Jason D. Lee, Deming Chen, and Tri Dao. 2024. Medusa: Simple LLM Inference Acceleration Framework with Multiple Decoding Heads. In PMLR . 5209â€“5235. [9] Neal Cardwell, Yuchung Cheng, C Stephen Gunn, Soheil Hassas Yeganeh, and Van Jacobson. 2016. Bbr: Congestion-based congestion control: Measuring bottleneck bandwidth and round-trip propagation time. Queue (2016), 20â€“53. [10] Charlie Chen, Sebastian Borgeaud, Geoffrey Irving, Jean-Baptiste Lespiau, Lau-rent Sifre, and John Jumper. 2023. Accelerating large language model decoding with speculative sampling. arXiv:2302.01318 [11] Jiawei Chen, Hongyu Lin, Xianpei Han, and Le Sun. 2024. Benchmarking large language models in retrieval-augmented generation. In AAAI . 17754â€“17762. [12] Lars Daniel. 2025. DeepSeek Data Leak Exposes 1 Million Sensitive Records. 

Forbes (2025). https://www.forbes.com/sites/larsdaniel/2025/02/01/deepseek-data-leak-exposes--1000000-sensitive-records/ [13] DeepSeek-AI. 2024. DeepSeek-V3 Technical Report. arXiv:2412.19437 [14] Yucheng Ding, Chaoyue Niu, Fan Wu, Shaojie Tang, Chengfei Lyu, and Guihai Chen. 2024. Enhancing on-device llm inference with historical cloud-based llm interactions. In SIGKDD . 597â€“608. [15] Kelvin Guu, Kenton Lee, Zora Tung, Panupong Pasupat, and Mingwei Chang. 2020. Retrieval augmented language model pre-training. In ICML . 3929â€“3938. [16] Ari Holtzman, Jan Buys, Li Du, Maxwell Forbes, and Yejin Choi. 2020. The Curious Case of Neural Text Degeneration. In ICLR .[17] Coleman Hooper, Sehoon Kim, Hiva Mohammadzadeh, Hasan Genc, Kurt Keutzer, Amir Gholami, and Yakun Sophia Shao. 2023. SPEED: Speculative Pipelined Execution for Efficient Decoding. arXiv:2310.12072 [18] Coleman Hooper, Sehoon Kim, Hiva Mohammadzadeh, Michael W. Mahoney, Yakun Sophia Shao, Kurt Keutzer, and Amir Gholami. 2024. KVQuant: Towards 10 Million Context Length LLM Inference with KV Cache Quantization. In NIPS .1270â€“1303. [19] Chuang Hu, Wei Bao, Dan Wang, and Fengming Liu. 2019. Dynamic adaptive DNN surgery for inference acceleration on the edge. ICCC (2019), 1423â€“1431. [20] Junxian Huang, Feng Qian, Alexandre Gerber, Z Morley Mao, Subhabrata Sen, and Oliver Spatscheck. 2012. A close examination of performance and power characteristics of 4G LTE networks. In MobiSys . 225â€“238. [21] Data is Better-Together. 2024. data-is-better-together/10k_prompts_ranked. https://huggingface.co/datasets/data-is-better-together/10k_prompts_ranked. Accessed: 2025-03-31. [22] Gautier Izacard, Mathilde Caron, Lucas Hosseini, Sebastian Riedel, Piotr Bo-janowski, Armand Joulin, and Edouard Grave. 2021. Unsupervised Dense Infor-mation Retrieval with Contrastive Learning. https://arxiv.org/abs/2112.09118 [23] Gautier Izacard and Edouard Grave. 2021. Leveraging Passage Retrieval with Generative Models for Open Domain Question Answering. In EACL . 874â€“880. [24] Zhengbao Jiang, Frank Xu, Luyu Gao, Zhiqing Sun, Qian Liu, Jane Dwivedi-Yu, Yiming Yang, Jamie Callan, and Graham Neubig. 2023. Active Retrieval Augmented Generation. In EMNLP . 7969â€“7992. [25] Hongpeng Jin and Yanzhao Wu. 2024. CE-CoLLM: Efficient and Adaptive Large Language Models Through Cloud-Edge Collaboration. arXiv:2411.02829 [26] Jeff Johnson, Matthijs Douze, and HervÃ© JÃ©gou. 2019. Billion-scale similarity search with GPUs. IEEE Transactions on Big Data 3 (2019), 535â€“547. [27] Peter Kairouz, H Brendan McMahan, Brendan Avent, AurÃ©lien Bellet, Mehdi Bennis, Arjun Nitin Bhagoji, Kallista Bonawitz, Zachary Charles, Graham Cor-mode, Rachel Cummings, et al . 2021. Advances and open problems in federated learning. Foundations and Trends in Machine Learning 1â€“2 (2021), 1â€“210. [28] Yiping Kang, Johann Hauswald, Cao Gao, Austin Rovinski, Trevor Mudge, Jason Mars, and Lingjia Tang. 2017. Neurosurgeon: Collaborative intelligence between the cloud and mobile edge. ACM SIGARCH Computer Architecture News 1 (2017), 615â€“629. [29] Vladimir Karpukhin, Barlas OÄŸuz, Sewon Min, Patrick Lewis, Ledell Wu, Sergey Edunov, Danqi Chen, and Wen-tau Yih. 2020. Dense passage retrieval for open-domain question answering. In EMNLP . 6769â€“6781. [30] Urvashi Khandelwal, Omer Levy, Dan Jurafsky, Luke Zettlemoyer, and Mike Lewis. 2020. Generalization through Memorization: Nearest Neighbor Language Models. In ICLR .[31] LangChain. 2025. langchain-ai/langchain: Build context-aware reasoning appli-cations. https://github.com/langchain-ai/langchain. [32] Stefanos Laskaridis, Stylianos I Venieris, Mario Almeida, Ilias Leontiadis, and Nicholas D Lane. 2020. SPINN: synergistic progressive inference of neural networks over device and cloud. MobiCom (2020), 1â€“15. [33] Yaniv Leviathan, Matan Kalman, and Yossi Matias. 2023. Fast inference from transformers via speculative decoding. In ICML . 19274â€“19286. [34] Yaniv Leviathan, Matan Kalman, and Yossi Matias. 2023. Fast Inference from Transformers via Speculative Decoding. In ICML . 19274â€“19286. [35] Patrick Lewis, Ethan Perez, Aleksandra Piktus, Fabio Petroni, Vladimir Karpukhin, Naman Goyal, Heinrich KÃ¼ttler, Mike Lewis, Wen-tau Yih, Tim Rock-tÃ¤schel, et al . 2020. Retrieval-augmented generation for knowledge-intensive nlp tasks. In NIPS . 9459â€“9474. [36] Patrick S. H. Lewis, Ethan Perez, Aleksandra Piktus, Fabio Petroni, Vladimir Karpukhin, Naman Goyal, Heinrich KÃ¼ttler, Mike Lewis, Wen-tau Yih, Tim RocktÃ¤schel, Sebastian Riedel, and Douwe Kiela. 2020. Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks. In NIPS . 9459â€“9474. [37] Zicheng Lin, Tian Liang, Jiahao Xu, Xing Wang, Ruilin Luo, Chufan Shi, Siheng Li, Yujiu Yang, and Zhaopeng Tu. 2024. Critical Tokens Matter: Token-Level Contrastive Estimation Enhence LLMâ€™s Reasoning Capability. arXiv:2411.19943 [38] Hongyin Luo, Tianhua Zhang, Yung-Sung Chuang, Yuan Gong, Yoon Kim, Xixin Wu, Helen Meng, and James Glass. 2023. Search Augmented Instruction Learning. In EMNLP . 3717â€“3729. [39] Yu Ma, Weifa Liang, Jing Li, Xiaohua Jia, and Song Guo. 2020. Mobility-aware and delay-sensitive service provisioning in mobile edge-cloud networks. TMC 1(2020), 196â€“210. [40] Pavel Mach and Zdenek Becvar. 2017. Mobile Edge Computing: A Survey on Architecture and Computation Offloading. IEEE Communications Surveys and Tutorials 3 (2017), 1628â€“1656. [41] Stephen Merity, Caiming Xiong, James Bradbury, and Richard Socher. 2016. Pointer Sentinel Mixture Models. arXiv:1609.07843 [cs.CL] [42] OpenAI. 2023. GPT-4 Technical Report. arXiv:2303.08774 [43] Yanghe Pan, Zhou Su, Yuntao Wang, Shaolong Guo, Han Liu, Ruidong Li, and Yuan Wu. 2024. Cloud-Edge Collaborative Large Model Services: Challenges and Solutions. IEEE Network (2024), 1â€“1. [44] Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. 2017. Automatic differentiation in PyTorch. [45] Guanqiao Qu, Qiyuan Chen, Wei Wei, Zheng Lin, Xianhao Chen, and Kaibin Huang. [n. d.]. Mobile Edge Intelligence for Large Language Models: A Contem-porary Survey. arXiv:2407.18921 [46] Ori Ram, Yoav Levine, Itay Dalmedigos, Dor Muhlgay, Amnon Shashua, Kevin Leyton-Brown, and Yoav Shoham. 2023. In-context retrieval-augmented language models. TACL (2023), 1316â€“1331. [47] Nir Ratner, Yoav Levine, Yonatan Belinkov, Ori Ram, Inbal Magar, Omri Abend, Ehud Karpas, Amnon Shashua, Kevin Leyton-Brown, and Yoav Shoham. 2023. Parallel Context Windows for Large Language Models. In ACL . 6383â€“6402. [48] Nils Reimers and Iryna Gurevych. 2019. Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks. In EMNLP . Association for Computational Lin-guistics. https://arxiv.org/abs/1908.10084 [49] Rulin Shao, Jacqueline He, Akari Asai, Weijia Shi, Tim Dettmers, Sewon Min, Luke Zettlemoyer, and Pang Wei Koh. 2024. Scaling Retrieval-Based Language Models with a Trillion-Token Datastore. In NIPS . 91260â€“91299. [50] Weijia Shi, Xiaochuang Han, Mike Lewis, Yulia Tsvetkov, Luke Zettlemoyer, and Wen-tau Yih. 2024. Trusting Your Evidence: Hallucinate Less with Context-aware Decoding. In NAACL . 783â€“791. [51] Weijia Shi, Sewon Min, Michihiro Yasunaga, Minjoon Seo, Rich James, Mike Lewis, Luke Zettlemoyer, and Wen-tau Yih. 2024. REPLUG: Retrieval-Augmented Black-Box Language Models. In NAACL . 8371â€“8384. [52] Milad Shokouhi, Luo Si, et al . 2011. Federated Search. Foundations and Trends Â®

in Information Retrieval 1 (2011), 1â€“102. [53] Mitchell Stern, Noam Shazeer, and Jakob Uszkoreit. 2018. Blockwise Parallel Decoding for Deep Autoregressive Models. In NIPS . 10107â€“10116. [54] Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement De-langue, Anthony Moi, Pierric Cistac, Tim Rault, RÃ©mi Louf, Morgan Funtowicz, et al . 2019. Huggingfaceâ€™s transformers: State-of-the-art natural language pro-cessing. arXiv preprint arXiv:1910.03771 (2019). [55] Heming Xia, Tao Ge, Peiyi Wang, Si-Qing Chen, Furu Wei, and Zhifang Sui. 2023. Speculative Decoding: Exploiting Speculative Execution for Accelerating Seq2seq Generation. In EMNLP . 3909â€“3925. [56] Menglin Xia, Xuchao Zhang, Camille Couturier, Guoqing Zheng, Saravan Ra-jmohan, and Victor RÃ¼hle. 2024. Hybrid-RACA: Hybrid Retrieval-Augmented Composition Assistance for Real-time Text Prediction. In EMNLP . 120â€“131. [57] An Yang, Baosong Yang, Beichen Zhang, Binyuan Hui, Bo Zheng, Bowen Yu, Chengyuan Li, Dayiheng Liu, Fei Huang, Haoran Wei, et al . 2024. Qwen2.5 technical report. arXiv:2412.15115 [58] Seongjun Yang, Gibbeum Lee, Jaewoong Cho, Dimitris Papailiopoulos, and Kang-wook Lee. 2024. Predictive Pipelined Decoding: A Compute-Latency Trade-off for Exact LLM Decoding. TMLR (2024). [59] Michihiro Yasunaga, Armen Aghajanyan, Weijia Shi, Rich James, Jure Leskovec, Percy Liang, Mike Lewis, Luke Zettlemoyer, and Wen-tau Yih. 2023. Retrieval-augmented multimodal language modeling. In ICML . Article 1659, 15 pages. [60] Jun Zhang, Jue Wang, Huan Li, Lidan Shou, Ke Chen, Gang Chen, and Sharad Mehrotra. 2024. Draft& Verify: Lossless Large Language Model Acceleration via Self-Speculative Decoding. In ACL . 11263â€“11282. [61] Shigeng Zhang, Yinggang Li, Xuan Liu, Song Guo, Weiping Wang, Jianxin Wang, Bo Ding, and Di Wu. 2020. Towards real-time cooperative deep inference over the cloud and edge end devices. ACM on Interactive, Mobile, Wearable and Ubiquitous Technologies 2 (2020), 1â€“24. [62] Susan Zhang, Stephen Roller, Naman Goyal, Mikel Artetxe, Moya Chen, Shuohui Chen, Christopher Dewan, Mona Diab, Xian Li, Xi Victoria Lin, Todor Mihaylov, 

11 Myle Ott, Sam Shleifer, Kurt Shuster, Daniel Simig, Punit Singh Koura, Anjali Sridhar, Tianlu Wang, and Luke Zettlemoyer. 2022. OPT: Open Pre-trained Transformer Language Models. arXiv:2205.01068 [cs.CL] [63] Zhenyu Zhang, Ying Sheng, Tianyi Zhou, Tianlong Chen, Lianmin Zheng, Ruisi Cai, Zhao Song, Yuandong Tian, Christopher RÃ©, Clark Barrett, Zhangyang Wang, and Beidi Chen. 2023. H2O: heavy-hitter oracle for efficient generative inference of large language models. In NIPS . Article 1506, 50 pages. [64] Wayne Xin Zhao, Kun Zhou, Junyi Li, Tianyi Tang, Xiaolei Wang, Yupeng Hou, Yingqian Min, Beichen Zhang, Junjie Zhang, Zican Dong, et al . 2023. A survey of large language models. arXiv:2303.18223 

## A Appendix A.1 Numerical Stability 

We leverage the log-sum-exp trick to enhance numerical stability. Specifically, after decoding a draft token on each side ğ‘  , the corrected value of â„ğ‘  ğ‘¡ is computed as 

Ëœâ„ğ‘  ğ‘¡ = log âˆ‘ï¸ ğ‘‘ âˆˆğ· ğ‘  exp (R ( ğ‘‘, ğ‘¥ <ğ‘¡ )) .

and is synchronized across both sides along with log ğ’‘ ğ‘  ğ‘¡ . During aggregation, we compute log ğœ‚ ğ‘  ğ‘¡ as follows: 

log softmax ([ Ëœâ„ğ‘™ ğ‘¡ , Ëœâ„ğ‘Ÿ ğ‘¡ ]) = log exp Ëœâ„ğ‘  ğ‘¡ 

exp Ëœâ„ğ‘™ ğ‘¡ + exp Ëœâ„ğ‘Ÿ ğ‘¡ 

= log 

Ãğ‘‘ âˆˆğ· ğ‘  exp R ( ğ‘‘, ğ‘¥ <ğ‘¡ )

Ã

ğ‘‘ â€² âˆˆğ· ğ‘™ âˆªğ· ğ‘Ÿ exp R ( ğ‘‘ â€², ğ‘¥ <ğ‘¡ ) = log â„ğ‘  ğ‘¡ 

â„ğ‘™ ğ‘¡ + â„ğ‘Ÿ ğ‘¡ 

= log (ğœ‚ ğ‘  ğ‘¡ ).

The log of the target distribution log ğ’‘ ğ‘¡ is then obtained by: 

log âˆ‘ï¸ ğ‘  âˆˆ { ğ‘™,ğ‘Ÿ } exp (log ğ’‘ ğ‘  ğ‘¡ + log ğœ‚ ğ‘  ğ‘¡ ) = log (ğ‘ ğ‘™ ğ‘¡ ğœ‚ ğ‘™ ğ‘¡ + ğ‘ ğ‘Ÿ ğ‘¡ ğœ‚ ğ‘Ÿ ğ‘¡ ) = log ğ’‘ ğ‘¡ .

On one hand, both the log-sum-exp and log-softmax operations are inherently numerically stable. On the other hand, since our data compression algorithm only transmits the top-ğ‘ values of the locally-aggregated output distributions, it effectively avoids numerical underflow of log ğ’‘ ğ‘  ğ‘¡ .

## A.2 Correctness of the Aggregation Strategy 

We will show that for any locally-aggregated distributions ğ’‘ ğ‘™ ğ‘¡ and 

ğ’‘ ğ‘Ÿ ğ‘¡ , the target token ğ‘¥ ğ‘¡ produced by the aggregation strategy follows a distribution identical to that sampled from ğ’‘ ğ‘¡ = ğœ‚ ğ‘™ ğ‘¡ ğ’‘ ğ‘™ ğ‘¡ + ğœ‚ ğ‘Ÿ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ ,where {ğ‘™, ğ‘Ÿ } = {ğ‘‘ğ‘’ğ‘£ğ‘–ğ‘ğ‘’, ğ‘ğ‘™ğ‘œğ‘¢ğ‘‘ }.First, we demonstrate that the intermediate outputs Ëœğ‘¥ ğ‘™ ğ‘¡ and Ëœğ‘¥ ğ‘Ÿ ğ‘¡ 

from the two independent speculative sampling processes are in-deed drawn from ğ’‘ ğ‘¡ . Note that, since ğœ‚ ğ‘  ğ‘¡ = â„ğ‘  ğ‘¡ /( â„ğ‘™ ğ‘¡ +â„ğ‘Ÿ ğ‘¡ ) for ğ‘  âˆˆ { ğ‘™, ğ‘Ÿ },we have ğœ‚ ğ‘™ ğ‘¡ + ğœ‚ ğ‘Ÿ ğ‘¡ = 1.For side ğ‘™ , the probability to reject a draft token is 

ğ‘ƒ (ğ‘Ÿğ‘’ ğ‘—ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ ) = ğ¸ ğ‘¥ âˆ¼ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ) (1 âˆ’ min (1, ğœ‚ ğ‘™ ğ‘¡ + ğœ‚ ğ‘Ÿ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ )/ ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ))) 

= 1 âˆ’âˆ‘ï¸ min (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ), ğœ‚ ğ‘™ ğ‘¡ ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ) + ğœ‚ ğ‘Ÿ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ )) 

= 1 âˆ’âˆ‘ï¸ (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ) + min (0, ğœ‚ ğ‘Ÿ ğ‘¡ (ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ) âˆ’ ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ )))) 

= ğœ‚ ğ‘Ÿ ğ‘¡ âˆ‘ï¸ âˆ’ min (0, ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ) âˆ’ ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ )) 

= ğœ‚ ğ‘Ÿ ğ‘¡ âˆ‘ï¸ (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ) âˆ’ min (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ), ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ))) .Dec 1                          

> 2
> 3
> 4
> 5
> 6
> Remote Tokens
> Trans
> Dec Trans
> Dec Trans
> Dec Trans
> Dec
> Dec
> Trans
> Trans
> Dec
> 012345678910 11 12 13 14 15
> Time
> 1
> 2
> 3
> 4
> 5
> 6
> Local Tokens
> Dec
> Aggr. 1 Aggr. 2 Aggr. 3 Aggr. 4 Aggr. 5 Aggr. 6
> Trans
> Dec
> Trans
> Trans
> Dec Trans
> Dec Dec Trans
> Dec Dec
> Dec
> Trans
> Dec
> Dec
> Trans
> Dec Trans

Figure 10: Decoding pipeline when the Aggregator continu-ously rejects ğ‘¥ ğ‘™ and accepts ğ‘¥ ğ‘Ÿ .

The adjusted distribution, from which we sample after the draft token is rejected, can be expressed as 

Ëœğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ) = norm (max (0, ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ) âˆ’ ğ‘ ğ‘™ ğ‘¡ (ğ‘¥ )) 

= norm (ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ) âˆ’ min (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ), ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ))) 

= ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ) âˆ’ min (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ), ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ )) 

Ãğ‘¥ â€² (ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ â€²) âˆ’ min (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ â€²), ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ â€²))) .

Since Ã(ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ) âˆ’ min (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ), ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ))) is equivalent to Ã(ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ )âˆ’ min (ğ’‘ ğ‘™ ğ‘¡ (ğ‘¥ ), ğ’‘ ğ‘Ÿ ğ‘¡ (ğ‘¥ ))) , ğ‘ƒ (ğ‘Ÿğ‘’ ğ‘—ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘, ğ‘¥ = Ëœğ‘¥ ğ‘™ ğ‘¡ ), the probability that Ëœğ‘¥ ğ‘™ ğ‘¡ 

is re-sampled after rejecting ğ‘¥ ğ‘™ ğ‘¡ , is 

ğ‘ƒ (ğ‘Ÿğ‘’ ğ‘—ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ ) Ëœğ’‘ ğ‘™ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ) = ğœ‚ ğ‘Ÿ ğ‘¡ (ğ’‘ ğ‘Ÿ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ) âˆ’ min (ğ’‘ ğ‘™ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ), ğ’‘ ğ‘Ÿ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ))) .

Finally, the sampled token Ëœğ‘¥ ğ‘™ ğ‘¡ follows the distribution 

ğ‘ƒ (ğ‘¥ = Ëœğ‘¥ ğ‘™ ğ‘¡ ) = ğ‘ƒ (ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘, ğ‘¥ = Ëœğ‘¥ ğ‘™ ğ‘¡ ) + ğ‘ƒ (ğ‘Ÿğ‘’ ğ‘—ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘, ğ‘¥ = Ëœğ‘¥ ğ‘™ ğ‘¡ )

= ğ’‘ ğ‘™ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ) min (1, ğœ‚ ğ‘™ ğ‘¡ + ğœ‚ ğ‘Ÿ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ )/ ğ’‘ ğ‘™ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ )) + ğœ‚ ğ‘Ÿ ğ‘¡ (ğ’‘ ğ‘Ÿ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ) âˆ’ min (ğ’‘ ğ‘™ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ), ğ’‘ ğ‘Ÿ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ))) 

= ğœ‚ ğ‘™ ğ‘¡ ğ’‘ ğ‘™ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ) + ğœ‚ ğ‘Ÿ ğ‘¡ min (ğ’‘ ğ‘™ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ), ğ’‘ ğ‘Ÿ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ )) + ğœ‚ ğ‘Ÿ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ) âˆ’ ğœ‚ ğ‘Ÿ ğ‘¡ min (ğ’‘ ğ‘™ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ), ğ’‘ ğ‘Ÿ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ))) 

= ğœ‚ ğ‘™ ğ‘¡ ğ’‘ ğ‘™ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ) + ğœ‚ ğ‘Ÿ ğ‘¡ ğ’‘ ğ‘Ÿ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ) = ğ’‘ ğ‘¡ ( Ëœğ‘¥ ğ‘™ ğ‘¡ ).

As a result, Ëœğ‘¥ ğ‘™ ğ‘¡ is distributed identically to tokens sampled from ğ’‘ ğ‘¡ .Since the correctness proof for the other side ğ‘Ÿ is symmetric, we can conclude straightforwardly that Ëœğ‘¥ ğ‘Ÿ ğ‘¡ âˆ¼ ğ’‘ ğ‘¡ .Finally, the aggregation strategy randomly select either Ëœğ‘¥ ğ‘™ ğ‘¡ or 

Ëœğ‘¥ ğ‘Ÿ ğ‘¡ as the target token ğ‘¥ ğ‘¡ , with a uniform probability. Obviously, 

ğ‘¥ ğ‘¡ âˆ¼ 0.5ğ’‘ ğ‘¡ + 0.5ğ’‘ ğ‘¡ = ğ’‘ ğ‘¡ .

## A.3 Decoding Pipelines 

Apart from the theoretical analysis of latency per token in Sec-tion 5, we use pipeline graphs to illustrate scenarios where each acceptance case repeats continuously. This is not necessarily how pipelines occur in practice, but it provides us with an heuristics of the scheduling strategy. In the following discussion, we define ğ‘™ as the side responsible for aggregation (i.e., the local side) and ğ‘Ÿ as the other side (i.e., the remote side). We set random delays to analyze specific cases where all time values are expressed in the same unit. 12 Dec 1                   

> 2
> 3
> 4
> 5
> 6
> Remote Tokens
> Dec
> Trans
> Dec
> Trans
> Trans
> Dec Trans
> Dec
> Dec
> Trans
> Dec
> Trans
> Trans
> Dec
> Dec
> Trans
> Dec
> Trans
> Trans
> Dec
> Dec
> Dec
> 012345678910 11 12 13 14 15
> Time
> 1
> 2
> 3
> 4
> 5
> 6
> Local Tokens
> Aggregation 1 Aggregation 2 Aggregation 3
> Trans
> Dec Dec
> Trans
> Dec
> Trans
> Trans
> Dec
> Dec
> Trans
> Dec
> Trans
> Dec
> Trans

Figure 13: Decoding pipeline when the Aggregator continu-ously rejects both ğ‘¥ ğ‘™ and ğ‘¥ ğ‘Ÿ .Dec 1                          

> 2
> 3
> 4
> 5
> 6
> Remote Tokens
> Trans
> Dec Trans Dec Trans
> Dec Trans Dec Trans
> Dec Trans Trans Dec
> Dec
> 012345678910 11 12 13 14 15
> Time
> 1
> 2
> 3
> 4
> 5
> 6
> Local Tokens
> Aggr. 1 Aggr. 2 Aggr. 3
> Dec
> Trans
> Trans
> Dec
> Trans
> Dec
> Trans
> Trans
> Trans
> Dec Trans
> Dec
> Trans
> Trans

Figure 11: Decoding pipeline when the Aggregator continu-ously accepts ğ‘¥ ğ‘™ and rejects ğ‘¥ ğ‘Ÿ .Dec 1                       

> 2
> 3
> 4
> 5
> 6
> Remote Tokens
> Dec
> Trans
> Trans
> Dec
> Dec
> Trans
> Trans
> Dec Trans
> Dec Trans
> Dec
> 012345678910 11 12 13 14 15
> Time
> 1
> 2
> 3
> 4
> 5
> 6
> Local Tokens
> Dec
> Aggr. 1 Aggr. 2 Aggr. 3 Aggr. 4 Aggr. 5 Aggr. 6
> Trans
> Dec
> Trans
> Dec
> Trans
> Dec
> Trans
> Trans
> Dec Trans

Figure 12: Decoding pipeline when the Aggregator continu-ously accepts both ğ‘¥ ğ‘™ and ğ‘¥ ğ‘Ÿ .i) Continuously reject ğ‘¥ ğ‘™ and accept ğ‘¥ ğ‘Ÿ . The pipeline is shown in Figure 10, where ğ‘ ğ‘™ 

trans = 1.2, ğ‘ ğ‘Ÿ 

trans = 1.8, ğ‘ ğ‘™ 

dec = 1, and ğ‘ ğ‘Ÿ 

dec = 1.5.The latency bottleneck is ğ‘ ğ‘Ÿ 

dec , causing ğ‘™ to wait for ğ‘¥ ğ‘Ÿ 

1 before the first Aggregation. As ğ‘™ generates draft tokens faster, subsequent aggregations begin upon the arrival of each ğ‘¥ ğ‘Ÿ ğ‘¡ . When ğ‘Ÿ decodes faster, the bottleneck becomes ğ‘ ğ‘™ 

dec . As a result, the latency per token is max (ğ‘ ğ‘™ 

dec , ğ‘ ğ‘Ÿ 

dec ).

ii) Continuously accept ğ‘¥ ğ‘™ and reject ğ‘¥ ğ‘Ÿ . The pipeline is shown in Figure 11, where ğ‘ ğ‘™ 

trans = 1.5, ğ‘ ğ‘Ÿ 

trans = 1, ğ‘ ğ‘™ 

dec = 2, and 

ğ‘ ğ‘Ÿ 

dec = 2. Although ğ‘ ğ‘™ 

dec = ğ‘ ğ‘Ÿ 

dec , local draft tokens do not require transmission; therefore, the latency bottleneck thus lies on the remote side. After each aggregation at step ğ‘¡ , ğ‘™ must wait for a duration of ğ‘ ğ‘™ 

trans + ğ‘ ğ‘Ÿ 

dec + ğ‘ ğ‘Ÿ 

trans , including the transmission of tar-get token ğ‘¥ ğ‘¡ , as well as the decoding and transmission of the re-mote draft token ğ‘¥ ğ‘Ÿ ğ‘¡ +1. Only when ğ‘ ğ‘™ 

dec exceeds this duration, the bottleneck shifts to the local side. The latency per token is thus 

max (ğ‘ ğ‘™ 

dec , ğ‘ ğ‘™ 

trans + ğ‘ ğ‘Ÿ 

dec + ğ‘ ğ‘Ÿ 

trans ).

iii) Continuously accept both ğ‘¥ ğ‘™ and ğ‘¥ ğ‘Ÿ . The pipeline is shown in Figure 12, where ğ‘ ğ‘™ 

trans = 1.5, ğ‘ ğ‘Ÿ 

trans = 1.8, ğ‘ ğ‘™ 

dec = 1, and ğ‘ ğ‘Ÿ 

dec = 1.5.Clearly, the bottleneck lies on the side with the larger decoding delay. Consequently, the latency per token is max (ğ‘ ğ‘™ 

dec , ğ‘ ğ‘Ÿ 

dec ).

iv) Continuously reject both ğ‘¥ ğ‘™ and ğ‘¥ ğ‘Ÿ The pipeline is shown in Figure 13, where ğ‘ ğ‘™ 

trans = 1.5, ğ‘ ğ‘Ÿ 

trans = 1.8, ğ‘ ğ‘™ 

dec = 2, and ğ‘ ğ‘Ÿ 

dec =

1. Since rejecting the local draft token resets ğœ‘ (ğ‘ ğ‘™ 

dec ) to ğ‘ ğ‘™ 

dec , the scenario is exactly the same as ii). The latency per token is computed as max (ğ‘ ğ‘™ 

dec , ğ‘ ğ‘™ 

trans + ğ‘ ğ‘Ÿ 

dec + ğ‘ ğ‘Ÿ 

trans ).13
