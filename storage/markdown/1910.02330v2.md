Title: 

URL Source: http://arxiv.org/pdf/1910.02330v2

Published Time: Mon, 23 Jan 2023 02:26:22 GMT

Markdown Content:
# Towards Deployment of Robust AI Agents for Human-Machine Partnerships 

Ahana Ghosh 

MPI-SWS 

gahana@mpi-sws.org 

Sebastian Tschiatschek 

Microsoft Research 

setschia@microsoft.com 

Hamed Mahdavi 

MPI-SWS 

hmahdavi@mpi-sws.org 

Adish Singla 

MPI-SWS 

adishs@mpi-sws.org 

## Abstract 

We study the problem of designing AI agents that can robustly cooperate with people in human-machine partnerships. Our work is inspired by real-life scenarios in which an AI agent, e.g., a virtual assistant, has to cooperate with new users after its deployment. We model this problem via a parametric MDP framework where the parameters correspond to a user’s type and characterize her behavior. In the test phase, the AI agent has to interact with a user of unknown type. Our approach to designing a robust AI agent relies on observing the user’s actions to make inferences about the user’s type and adapting its policy to facilitate efficient cooperation. We show that without being adaptive, an AI agent can end up performing arbitrarily bad in the test phase. We develop two algorithms for computing policies that automatically adapt to the user in the test phase. We demonstrate the effectiveness of our approach in solving a two-agent collaborative task. 

## 1 Introduction 

An increasing number of AI systems are deployed in human-facing applications like autonomous driving, medicine, and education [ Yu et al., 2017 ]. In these applications, the human-user and the AI system (agent) form a partnership, necessitating mutual awareness for achieving optimal results [ Hadfield-Menell et al., 2016 , Wilson and Daugherty, 2018 , Amershi et al., 2019 ]. For instance, to provide high utility to a human-user, it is important that an AI agent can account for a user’s preferences defining her behavior and act accordingly, thereby being adaptive to the user’s type [ Nikolaidis et al., 2015 , Nikolaidis et al., 2017a , Amershi et al., 2019 ,Tschiatschek et al., 2019 , Haug et al., 2018 ]. As a concrete example, an AI agent for autonomous driving applications should account for a user’s preference to take scenic routes instead of the fastest route and account for the user’s need for more AI support when driving manually in confusing situations. AI agents that do not account for the user’s preferences and behavior typically degrade the utility for their human users. However, this is challenging because the AI agent needs to (a) infer in-formation about the interacting user and (b) be able to interact efficiently with a large number of different human users, each possibly showing different behaviors. In particular, during development of an AI agent, it is often only possible to interact with a limited number of human users and the AI agent needs to generalize to new users after deployment (or acquire information needed there-fore quickly). This resembles multi-agent reinforcement learning settings in which an AI agent faces unknown agents at test time [ Grover et al., 2018 ] and the cold-start problem in recommender systems [Bobadilla et al., 2012]. 

Safety and Robustness in Decision Making (SRDM) Workshop, NeurIPS 2019. 

> arXiv:1910.02330v2 [cs.LG] 15 Jun 2020

In this paper, we study the problem of designing AI agents that can robustly cooperate with new unknown users for human-machine partnerships in reinforcement learning (RL) settings after de-ployment. In these problems, the AI agent often only has access to the reward information during its development while no (explicit) reward information is available once the agent is deployed. As shown in this paper, an AI agent can only achieve high utility in this setting if it is adaptive to its user while a non-adaptive AI agent can perform arbitrarily bad. We propose two adaptive policies for our considered setting, one of which comes with strong theoretical robustness guarantees at test time, while the other is inspired by recent deep-learning approaches for RL and is easier to scale to larger problems. Both policies build upon inferring the human user’s properties and leverage these inferences to act robustly. Our approach is related to ideas of multi-task, meta-learning, and generalization in reinforcement learning. However, most of these approaches require access to reward information at test time and rarely offer theoretical guarantees for robustness (see discussion on related work in Section 7). Below, we highlight our main contributions: • We provide an algorithmic framework for designing robust policies for interacting with agents of unknown behavior. Furthermore, we prove robustness guarantees for approaches building on our framework. • We propose two policies according to our framework: A DAPT POOL which pre-computes a set of best-response policies and executes them adaptively based on inferences of the type of human-user; and A DAPT DQN which implements adaptive policies by a neural network in combination with an inference module. • We empirically demonstrate the excellent performance of our proposed policies when facing an unknown user. 

## 2 The Problem Setup 

We formalize the problem through a reinforcement learning (RL) framework. The agents are hereafter referred to as agent Ax and agent Ay : here, agent Ay represents the AI agent whereas agent Ax could be a person, i.e., human user. Our goal is to develop a learning algorithm for agent Ay that leads to high utility even in cases when the behavior of agent Ax and its committed policy is unknown. 

2.1 The model 

We model the preferences and induced behavior of agent Ax via a parametric space Θ. From agent Ay ’s perspective, each θ ∈ Θ leads to a parameterized MDP M(θ) := ( S, A, T θ , R θ , γ, D0)

consisting of the following: • a set of states S, with s ∈ S denoting a generic state. • a set of actions A, with a ∈ A denoting a generic action of agent Ay .• a transition kernel parameterized by θ as Tθ (s′ | s, a ), which is a tensor with indices defined by the current state s, the agent Ay ’s action a, and the next state s′. In particular, 

Tθ (s′ | s, a ) = Eax [T x,y (s′ | s, a, a x)] , where ax ∼ πxθ (· | s) is sampled from agent Ax’s policy in state s. That is, Tθ (s′ | s, a ) corresponds to the transition dynamics derived from a two-agent MDP with transition dynamics T x,y and agent Ax’s policy πxθ .• a reward function parameterized by θ as Rθ : S × A → [0 , r max ] for rmax > 0. This captures the preferences of agent Ax that agent Ay should account for. • a discount factor γ ∈ [0 , 1) weighing short-term rewards against long-term rewards. • an initial state distribution D0.Our goal is to develop a learning algorithm that achieves high utility even in cases when θ is unknown. In line with the motivating applications discussed above, we consider the following two phases: • Training (development) phase. During development, our learning algorithm can iteratively interact with a limited number of different MDPs M(θ) for θ ∈ Θtrain ⊆ Θ: here, agent 

Ay can observe rewards as well as agent Ax’s actions needed for learning purposes. 2• Test (deployment) phase. After deployment, our learning algorithm interacts with a pa-rameterized MDP as described above for unknown θtest ∈ Θ: here, agent Ay only observes agent Ax’s actions but not rewards. 

2.2 Utility of agent Ay

For a fixed policy π of agent Ay , we define its total expected reward in the MDP Mθ as follows: 

Jθ (π) = E

[ ∞∑ 

> τ=1

γτ −1Rθ (sτ , a τ ) | D 0, T θ , π 

]

, (1) where the expectation is over the stochasticity of policy π and the transition dynamics Tθ . Here sτ is the state at time τ . For τ = 1 , this comes from the distribution D0.

For known θ. When the underlying parameter θ is known, the task of finding the best response policy of agent Ay reduces to the following: 

π∗ 

> θ

= arg max 

> π∈Π

Jθ (π) (2) where Π = {π | π : S × A → [0 , 1] } defines the set of stationary Markov policies. 

For unknown θ. However, when the underlying parameter θ ∈ Θ is unknown, we define the best response (in a minmax sense) policy π ∈ Π of agent Ay as: 

π∗ 

> Θ

= arg min 

> π∈Π

max 

> θ∈Θ

(

Jθ (π∗ 

> θ

) − Jθ (π)

)

(3) Clearly, Jθ (π∗ 

> θ

) − Jθ (π∗

> Θ

) ≥ 0 ∀θ ∈ Θ. In general, this gap can be arbitrarily large, as formally stated in the following theorem. 

Theorem 1. There exists a problem instance where the performance of agent Ay can be arbitrarily worse when agent Ax’s type θtest is unknown. In other words, the gap max θ∈Θ

(

Jθ (π∗ 

> θ

) − Jθ (π∗

> Θ

)

)

is arbitrarily high. The proof is presented in the supplementary material. Theorem 1 shows that the performance of agent 

Ay can be arbitrarily bad when it doesn’t know θtest and is restricted to execute a fixed stationary Markov policy. In the next section, we present an algorithmic framework for designing robust policies for agent Ay for unknown θtest .

## 3 Designing Robust Policies 

In this section, we introduce our algorithmic framework for designing robust policies for the AI agent 

Ay .

3.1 Algorithmic framework 

Our approach relies on observing the behavior (i.e., actions taken) to make inferences about the agent Ax’s type θ and adapting agent Ay ’s policy accordingly to facilitate efficient cooperation. This is inspired by how people make decisions in uncertain situations (e.g., ability to safely drive a car even if the other driver on the road is driving aggressively). The key intuition is that at test time, the agent Ay can observe agent Ax’s actions which are taken as ax ∼ πxθ (· | s) when in state s to infer θ, and in turn use this additional information to make an improved decision on which actions to take. More formally, we define the observation history available at the beginning of timestep t as 

Ot−1 = ( sτ , a xτ )τ =1 ,...,t −1 and use it to infer the type of agent Ax and act appropriately. In particular, we will make use of an I NFERENCE procedure (details provided in Section 5). Given 

Ot−1, this procedure returns an estimate of the type of agent Ax at time t given by θt ∈ Θ. Then, we consider stochastic policies of the form ψ : S × A × Θ → [0 , 1] . The space of these policies is given 3Algorithm 1 Algorithmic framework for robust policies 

Training phase  

> 1:

Input: parameter space Θtrain  

> 2:

adaptive policy ψ ← TRAINING (Θ train )

Test phase  

> 1:

Input: adaptive policy ψ 

> 2:

O0 ← ()  

> 3:

for t = 1 , 2, . . . do  

> 4:

Observe current state st 

> 5:

Estimate Ax’s type as θt ← INFERENCE (Ot−1) 

> 6:

Take action at ← ψ(st, θ t) 

> 7:

Observe Ax’s action axt ; Ot ← Ot−1 ⊕ (st, a xt ) 

> 8:

end for 

by Ψ = {ψ | ψ : S × A × Θ → [0 , 1] }. For a fixed policy ψ of agent Ay and fixed, unknown θ, we define its total expected reward in the MDP M(θ) as follows: 

Jθ (ψ) = E

[ ∞∑ 

> τ=1

γτ −1Rθ (sτ , a τ ) | D 0, T θ , ψ 

]

. (4) Note that at any time t, we have at ∼ ψ(st, θ t) and Ot−1 = ( sτ , a xτ )τ =1 ,...,t −1 is generated according to axτ ∼ πxθ (sτ ).We seek to find the policy for agent Ay given by the following optimization problem: 

min  

> ψ∈Ψ

max 

> θ∈Θ

(

Jθ (π∗ 

> θ

) − Jθ (ψ)

)

(5) In the next two sections, we will design algorithms to optimize the objective in Equation (5) following the framework outlined in Algorithm 1. In particular, we will discuss two possible architectures for policy ψ and corresponding T RAINING procedures in Section 4. Then, in Section 5, we describe ways to implement the I NFERENCE procedure for inferring agent Ax’s type using observed actions. Below, we provide theoretical insights into the robustness of the proposed algorithmic framework. 

3.2 Performance analysis 

We begin by specifying three technical questions that are important to gain theoretical insights into the robustness of the proposed framework, see below: Q.1 Independent of the specific procedures used for T RAINING and I NFERENCE , the first question to tackle is the following: When agent Ax’s true type is θtest and agent Ay uses a best response policy for π∗ 

> ˆθ

such that || θtest − ˆθ|| ≤ , what are the performance guarantees on the total utility achieved by agent Ay ? (see Theorem 2). Q.2 Regarding T RAINING procedure: When agent Ax’s type is θtest and the inference procedure outputs ˆθ such that || θtest − ˆθ|| ≤ , what is the performance of policy ψ? (see Section 4). Q.3 Regarding I NFERENCE procedure: When agent Ax’s type is θtest , can we infer ˆθ such that either 

|| θtest − ˆθ|| is small, or agent Ax’s policies πx 

> ˆθ

and πxθtest are approximately equivalent? (see Section 5) 

3.2.1 Smoothness properties 

For addressing Q.1, we introduce a number of properties characterizing our problem setting. These properties are essentially smoothness conditions on MDPs that enable us to make statements about the following intermediate issue: For two types θ, θ ′, how “similar" are the corresponding MDPs 

M(θ), M(θ′) from agent Ay ’s point of view? 4The first property characterizes the smoothness of rewards for agent Ay w.r.t. parameter θ. Formally, the parametric MDP M(θ) is α-smooth with respect to the rewards if for any θ and θ′ we have 

max  

> s∈S,a ∈A

|Rθ (s, a ) − Rθ′ (s, a )| ≤ α · rmax · || θ − θ′|| 2 (6) The second property characterizes the smoothness of policies for agent Ax w.r.t. parameter θ; this in turn implies that the MDP’s transition dynamics as perceived by agent Ay are smooth. Formally, the parametric MDP M(θ) is β-smooth in the behavior of agent Ax if for any θ and θ′ we have 

max  

> s∈S

KL (πxθ (. | s); πxθ′ (. | s)) ≤ β · || θ − θ′|| 2. (7) For instance, one setting where this property holds naturally is when πxθ is a soft Bellman policy computed w.r.t. a reward function for agent Ax which is smooth in θ [ Ziebart, 2010 ,Kamalaruban et al., 2019]. The third property is a notion of influence as introduced by [ Dimitrakakis et al., 2017 ]: This notion captures how much one agent can affect the probability distribution of the next state with her actions as perceived by the second agent. Formally, we capture the influence of agent Ax on agent Ay as follows: 

Ix := max 

> s∈S

( max  

> a,b,b ′

‖T x,y (. | s, a, b ) − T x,y (. | s, a, b ′)‖1

), (8) where a represents the action of agent Ay , b, b ′ represents two distinct actions of agent Ax, and T x,y 

is the transition dynamics of the two-agent MDP (see Section 2.1). Note that Ix ∈ [0 , 1] and allows us to do fine-grained performance analysis: for instance, when Ix = 0 , then agent Ax doesn’t affect the transition dynamics as perceived by agent Ay and we can expect to have better performance for agent Ay .

3.2.2 Guarantees 

Putting this together, we can provide the following guarantees as an answer for Q.1: 

Theorem 2. Let θtest ∈ Θ be the type of agent Ax at test time and agent Ay uses a policy π∗ 

> ˆθ

such that || θtest − ˆθ|| ≤ . The parameters (α, β, Ix) characterize the smoothness as defined above. Then, the total reward achieved by agent Ay satisfies the following guarantee 

Jθtest (π∗ 

> ˆθ

) ≥ Jθtest (π∗ 

> θtest

) −  · α · rmax 

1 − γ − Ix · √2 · β ·  · rmax 

(1 − γ)2

The proof of the theorem is provided in the supplementary material and builds up on the theory of approximate equivalence of MDPs by [ Even-Dar and Mansour, 2003 ]. In the next two sections, we provide specific instantiations of T RAINING and I NFERENCE procedures. 

## 4 TRAINING Procedures 

In this section, we present two procedures to train adaptive policies ψ (see T RAINING in Algorithm 1). 

4.1 TRAINING procedure A DAPT POOL 

The basic idea of A DAPT POOL is to maintain a pool POOL of best response policies for Ay and, in the test phase, switch between these policies based on inference of the type θtest .

4.1.1 Architecture of the policy ψ

The adaptive pool based policy ψ (A DAPT POOL ) consists of a pool ( POOL ) of best response policies corresponding to different possible agent Ax’s types θ, and a nearest-neighbor policy selection mechanism. In particular, when invoking A DAPT POOL for state st and inferred agent Ax’s type θt, the policy ψ(st, θ t) first identifies the most similar agent Ax in POOL , i.e., ˆθt = arg min θ∈Θtrain ‖θ − θt‖,and then executes an action at ∼ π∗

> ˆθt

(· | st) using the best response policy π∗

> ˆθt

.5INFERENCE             

> 𝑂 "#$
> 𝜃 "
> 𝜃 &"=argmin .∈123456 𝜃 −𝜃 "
> 𝑎 "~𝜋 .;<
> ∗(?|𝑠 ")
> 𝜋 .;<
> ∗
> 𝑠 "
> 𝑎 "
> Nearest -neighbor selection from P OOL

(a) Test phase in Algorithm 1 with policy ψ

trained using A DAPT POOL procedure. INFERENCE  

> 𝑂 "#$
> 𝜃 "𝑠 "
> 𝑎 "

(b) Test phase in Algorithm 1 with policy ψ

trained using A DAPT DQN procedure. 

Figure 1: Two different instantiations of Algorithm 1 with the adaptive policy ψ trained using procedures A DAPT POOL and A DAPT DQN. (a) ADAPT POOL trains a set of best response policies 

{π∗ 

> θ

| θ ∈ Θtrain }. In the test phase at time step t with θt as the output of I NFERENCE , the action at

is sampled from a distribution π∗

> ˆθt

(· | st) where ˆθt is the nearest match for θt in the set Θtrain . (b) 

ADAPT DQN trains one deep Q-Network (DQN) with an augmented state space given by (s, θ ). At time t, with θt as the output of I NFERENCE , the DQN network is given as input a tuple (st, θ t) and the network outputs an action at.

4.1.2 Training process 

During training we compute a pool of best response policies POOL for a set of possible agent Ax’s types Θtrain , see Algorithm 2. 

Algorithm 2 ADAPT POOL : Training process 

1: Input: Parameter space Θtrain 

2: POOL ← {} 

3: for each θiter ∈ Θtrain do 

4: π∗ 

> θiter

← best response policy for MDP M(θiter )

5: POOL ← POOL ∪ { (θiter , π ∗ 

> θiter

)}

6: end for 

7: return POOL 

4.1.3 Guarantees 

It turns out that if the set of possible agent Ax’s types Θtrain is chosen appropriately, Algorithm 1 instantiated with A DAPT POOL enjoys strong performance guarantees. In particular, choosing Θtrain 

as a sufficiently fine ′-cover of the parameter space Θ, ensures that for any θtest ∈ Θ, that we might encounter at test time, we have considered a sufficiently similar agent Ax during training and hence can execute a best response policy which achieves good performance, see corollary below. 

Corollary 3. Let Θtrain be an ′-cover for Θ, i.e., for all θ ∈ Θ, ∃θ′ ∈ Θtrain s.t. || θ − θ′|| ≤ ′. Let 

θtest ∈ Θ be the type of agent Ax and the I NFERENCE procedure outputs θt such that || θt −θtest || ≤ ′′ .Let  := ′ + ′′ . Then, at time t, the policy π∗

> ˆθt

used by agent Ay has the following guarantees: 

Jθtest (π∗

> ˆθt

) ≥ Jθtest (π∗ 

> θtest

) −  · α · rmax 

1 − γ − Ix · √2 · β ·  · rmax 

(1 − γ)2

Corollary 3 follows from the result of Theorem 2 given that the pool POOL of policies trained by ADAPT POOL is sufficiently rich. Note that the accuracy ′′ of I NFERENCE would typically improve over time and hence the performance of the algorithm is expected to improve over time in practice, see Section 6.2. Building on the idea of A DAPT POOL , next we provide a more practical implementation of training procedure which does not require to maintain an explicit pool of best response policies and therefore is easier to scale to larger problems. 

4.2 TRAINING procedure A DAPT DQN 

ADAPT DQN builds on the ideas of A DAPT POOL : Here, instead of explicitly maintaining a pool of best response policies for agent Ay , we have a policy network trained on an augmented state space 6S × Θ. This policy network resembles Deep Q-Network (DQN) architecture [ Mnih et al., 2015 ], but operates on an augmented state space and takes as input a tuple (s, θ ). Similar architecture was used by [ Hessel et al., 2019 ], where one policy network was trained to play 57 Atari games, and the state space was augmented with the index of the game. In the test phase, agent Ay selects actions given by this policy network. 

4.2.1 Architecture of the policy ψ

The adaptive policy ψ (A DAPT DQN) consists of a neural network trained on an augmented state space S × Θ. In particular, when invoking A DAPT DQN for state st and inferred agent Ax’s type 

θt, we use the augmented state space (st, θ t) as input to the neural network. The output layer of the network computes the Q-values of all possible actions corresponding to the augmented input state. Agent Ay selects the action with the maximum Q-value. 

4.2.2 Training process 

Here, we provide a description of how we train the policy network using augmented state space, see Algorithm 3. During one iteration of training the policy network, we first sample a parameter 

θiter ∼ Θtrain . We then obtain the optimal best response policy π∗ 

> θiter

of agent Ay for the MDP M(θiter ).We compute the vector of all Q-values corresponding to this policy, i.e, Q(s, a ) ∀s ∈ S, a ∈ A (repre-sented by Qπ∗ 

> θiter

in Algorithm 3), using the standard Bellman equations [ Sutton and Barto, 1998 ]. In our setting, we use these pre-computed Q-values to serve as the target values for the associated param-eter θiter for training the policy network. The loss function used for training is the standard squared error loss between the target Q-values computed using the procedure described above and those given by the network under training. The gradient of this loss function is used for back-propagation through the network. Multiple such iterations are carried out during training, until a convergence criteria is met. For more details on Deep Q-Networks, we refer the reader to see [Mnih et al., 2015]. 

Algorithm 3 ADAPT DQN: Training process  

> 1:

Input: Parameter space Θtrain  

> 2:

ψ ← Init. policy network on augmented state space  

> 3:

while convergence criteria is met do  

> 4:

sample θiter ∼ Uniform (Θ train ) 

> 5:

π∗ 

> θiter

← best response policy for MDP M(θiter ) 

> 6:

Qπ∗ 

> θiter

← Q-values for policy π∗ 

> θiter

in MDP M(θiter ) 

> 7:

Train ψ for one episode: (i) by augmenting the state space with θiter 

(ii) by using target Q-values Qπ∗ 

> θiter
> 8:

end while  

> 9:

return ψ

## 5 Inference Procedure 

In the test phase, the inference of agent Ax’s type θtest from an observation history Ot−1 is a key component of our framework, and crucial for facilitating efficient collaboration. Concretely, Theorem 2 implies that a best response policy π∗ 

> ˆθ

also achieves good performance for agent Ax with true parameter θtest if || ˆθ − θtest || is small and MDP M(θ) is smooth w.r.t. parameter θ as described in Section 3.2. There are several different approaches that one can consider for inference, depending on appli-cation setting. For instance, we can use probabilistic approaches as proposed in the work of [Everett and Roberts, 2018 ] where a pool of agent Ax’s policies πxθ ∀ θ ∈ Θ is maintained and infer-ence is done at run time via simple probabilistic methods. Based on the work by [ Grover et al., 2018 ], we can also maintain a more compact representation of agent Ax’s policies and then apply probabilis-tic methods on this representation. We can also do inference based on ideas of inverse reinforcement learning (IRL) where observation history Ot−1 serves the purpose of demonstrations [ Abbeel and Ng, 2004 , Ziebart, 2010 ]. This is 7𝒜 𝑥                

> 𝒜 𝑦
> +1
> +0.5 (a) θ= [+1 ,+0 .5] 𝒜 𝑥
> 𝒜 𝑦
> -1
> +0.8 (b) θ= [ −1,+0 .8] 𝒜 𝑥
> 𝒜 𝑦
> +1
> -1(c) θ= [+1 ,−1] 𝒜 𝑥
> 𝒜 𝑦
> -0. 5
> -0.5 (d) θ= [ −0.5,−0.5]

Figure 2: We evaluate the performance on a gathering game environment, a variant of the environ-ments considered by [ Leibo et al., 2017 ] and [ Raileanu et al., 2018 ]. The objective is to maximize the total reward by collecting fruits while avoiding collisions and agent Ax is assisted by agent Ay in achieving this objective. The environment has a 5x5 grid space resulting in 25 grid cells and the state space is determined by the joint location of agent Ax and agent Ay (i.e., |S| = 25 × 25 ). Actions 

are given by A ={‘step up’, ‘step left’, ‘step down’, ‘step right’, ‘stay’} . Each action is executed successfully with 0.8 probability; with random move probability of 0.2, the agent is randomly placed in one of the four neighboring cells located in vertical or horizontal positions. Two types of fruit objects are placed in two fixed grid cells (shown by ‘shaded blue’ and ‘blue’ cells). The rewards associated with these two fruit types are given by the parameter vector θ ∈ Θ where Θ := [ −1, +1] 2.In our environment, the location of these two fruit types is fixed and fruits do not disappear (i.e., there is an unlimited supply of each fruit type in their respective locations). For any fixed θ, agent Ax’s policy πxθ is computed first by ignoring the presence of agent Ay . From agent Ay ’s point of view, each θ gives rise to a parametric MDP M(θ). Transition dynamics Tθ in M(θ) are obtained by marginalizing out the effect of agent Ax’s policy πxθ . Reward function Rθ in M(θ) corresponds to the reward associated with fruits which depends on θ; in addition to collecting fruits, agent Ay should avoid collision or close proximity to agent Ax. This is enforced by a collision cost of −5 when agent 

Ay is in the same cell as agent Ax, and a proximity cost of −2 when agent Ay is in one of the four neighboring cells located in vertical or horizontal positions. The discount factor γ is set to 0.99, and the initial state distribution D0 corresponds to both agents starting in two corners. The above four illustrations correspond to four different θ parameters, highlighting agent Ax’s policy πxθ and the best response policy π∗ 

> θ

for agent Ay .particularly suitable when the parameter θ exactly corresponds to the rewards used by agent Ax when computing its policy πxθ . In fact, this is the approach that we follow for our inference module, and in particular, we employ the popular IRL algorithm, namely Maximum Causal Entropy (MCE) IRL algorithm [Ziebart, 2010]. We refer the reader to Section 6.1 for more details. 

## 6 Experiments 

We evaluate the performance of our algorithms using a gathering game environment, see Figure 2. Below, we provide details of the experimental setup and then discuss results. 

6.1 Experimental setup 6.1.1 Environment details 

For our experiments, we consider an episodic setting where two agents play the game repeatedly for multiple episodes enumerated as e = 1 , 2, . . . . Each episode of the game lasts for 500 steps. Now, to translate the episode count to time steps t as used in Algorithm 1 (line 3), we have t = 500 × e at the end of eth episode. For any fixed θ, agent Ax’s policy πxθ is computed first by ignoring the presence of agent Ay as described below—this is in line with our motivating applications where agent Ax is the human-agent with a pre-specified policy. In order to compute agent Ax’s policy πxθ , we consider agent 

Ax operating in a single-agent MDP denoted as Mx(θ) = ( Sx, A, R xθ , T x, γ, D x 

> 0

) where (i) s ∈ Sx

corresponds to the location of agent Ax in the grid-space, (ii) the action space is as described in Figure 2, (iii) the reward function Rxθ corresponds to reward associated with two fruit types given by θ, (iv) T x corresponds to transition dynamics of agent Ax alone in the environment, (v) discount 8factor γ = 0 .99 , and (vi) Dx 

> 0

corresponds to agent Ax starting in the upper-left corner (see Figure 2). Given Mx(θ), we compute πxθ as a soft Bellman policy – suitable to capture sub-optimal human behaviour in applications [Ziebart, 2010]. From agent Ay ’s point of view, each θ gives rise to a parametric MDP M(θ) in which agent Ay is operating in the game along with the corresponding agent Ax, see Figure 2. 

6.1.2 Baselines and implementation details. 

We use three baselines to compare the performance of our algorithms: (i) RAND corresponds to picking a random θ ∈ Θ and using best response policy π∗ 

> θ

, (ii) FIXED MM corresponds to the fixed best response (in a minmax sense) policy in Eq. 3, and (iii) FIXED BEST is a variant of FIXED MM and corresponds to the fixed best response (in a average sense) policy. We implemented two variants of A DAPT POOL which store policies corresponding to ′ = 1 and 

′ = 0 .25 covers of Θ (see Corollary 3), denoted as ADAPT POOL 1 and ADAPT POOL 0.25 in Figure 3. Next, we give specifications of the trained policy network used in A DAPT DQN. We used Θtrain to be a 0.25 level discretization of Θ. The trained network ψ has 3 hidden layers with leaky RELU-units (with α = 0 .1) having 64 , 32 , and 16 hidden units respectively, and a linear output layer with 5 units (corresponding to the size of action set |A|) (see [ Mnih et al., 2015 ] for more details on training Deep Q-Network). The input to the neural network is a concatenation of the location of the 2 agents, and the parameter vector θt, where |θt| = 2 (this corresponds to the augmented state space described in Section 4.2). The location of each agent is represented as a one-hot encoding of a vector of length 25 

corresponding to the number of grid cells Hence the length of the input vector to the neural network is 25 × 2 + 2 (= 52) . During training, agent Ay implemented epsilon-greedy exploratory policies (with exploration rate decaying linearly over training iterations from 1.0 to 0.01). Training lasted for about 50 million iterations. Our inference module is based on the MCE-IRL approach [ Ziebart, 2010 ] to infer θtest by observing actions taken by agent Ax’s policy. Note that, we are using MCE-IRL to infer the reward function parameters θtest used by agent Ax for computing its policy in the MDP Mx(θtest ) (see “Environment details" above). At the beginning, the inference module is initialized with θ0 = [0 , 0] , and its output at time t given by θt is based on history Ot−1. In particular, we implemented a sequential variant of MCE-IRL algorithm which updates the estimate θt only at the end of every episode e using stochastic gradient descent with learning rate η = 0 .001 . We refer the reader to [ Ziebart, 2010 ] for details on the original MCE-IRL algorithm and to [Kamalaruban et al., 2019] for the sequential variant. 

6.2 Results: Worst-case and average performance 

We evaluate the performance of algorithms on 441 different θtest obtained by a 0.1 level discretization of the 2-D parametric space Θ := [ −1, +1] 2. For a given θtest , the results were averaged over 10 

runs. Results are shown in Figure 3. As can be seen in Figure 3a, the worst-case performance of both ADAPT DQN and A DAPT POOL is significantly better than that of the three baselines ( FIXED BEST ,RAND and FIXED MM ), indicating robustness of our algorithmic framework. In our experiments, the FIXED MM and FIXED BEST baselines correspond to best response policies π∗ 

> θ

for θ = [0 .1, −1] and 

θ = [0 , −0.1] respectively. Under both these policies, agent Ay ’s behavior is qualitatively similar to the one shown in Figure 2c. As can be seen, under these policies, agent Ay avoids both fruits and avoids any collision; however, this does not allow agent Ay to assist agent Ax in collecting fruits even in scenarios where fruits have positive rewards. In Figure 3c, we show the convergence behavior of the inference module. Here, W ORST shows the worst case performance: As can be seen in the W ORST line, there are cases where the performance of the inference procedure is bad, i.e., ‖θt − θtest ‖ is large. This usually happens when different parameter values of θ results in agent Ax having equivalent policies. In these cases, estimating the exact θtest without any additional information is difficult. In our experiments, we noted that even if ‖θt − θtest ‖ is large, it is often the case that agent Ax’s policies πxθt and πxθtest are approximately equivalent which is important for getting a good approximation of the transition dynamics Tθtest .Despite the poor performance of the inference module in such cases, the performance of our algorithms is significantly better than the baselines (as is evident in Figure 3a). In the supplementary material, we provide additional experimental results corresponding to the algorithms’ performance for each individual θtest to gain further insights. 90 200 400 600 800 1000       

> Episode e(time t= 500 ×e)
> 010 20 30 40 50 60 70 80
> Jθtest (π∗
> θtest ) − Jθtest (Alg )
> Rand FixedBest FixedMM AdaptPool 1
> AdaptPool 0.25
> AdaptDQN

(a) Total reward: Worst-case 0 200 400 600 800 1000        

> Episode e(time t= 500 ×e)
> 0.02.55.07.510 .012 .515 .017 .520 .0
> Jθtest (π∗
> θtest ) − Jθtest (Alg )
> Rand FixedBest FixedMM AdaptPool 1
> AdaptPool 0.25
> AdaptDQN

(b) Total reward: Average-case 0 200 400 600 800 1000         

> Episode e(time t= 500 ×e)
> 0.00.20.40.60.81.01.21.4
> || θt − θtest || 2
> Worst Avg

(c) Inference module 

Figure 3: (a) Worst-case performance of both A DAPT DQN and A DAPT POOL is significantly bet-ter than that of the baselines, indicating robustness of our algorithmic framework. (a, b) Two variants of A DAPT POOL are shown corresponding to 1-cover and 0.25 -cover. As expected, the algorithm ADAPT POOL 0.25 with larger pool size has better performance compared to the algorithm ADAPT POOL 1. (c) Plot shows the convergence behavior of the inference module as more observa-tional data is gathered: A VG shows the average performance (averaged ‖θt − θtest ‖ w.r.t. different 

θtest ) and W ORST shows the worst case performance (maximum ‖θt − θtest ‖ w.r.t. different θtest ). -1 0 1   

> θtest [0]
> -1 01
> θtest [1]
> 015 30 45

(a) π∗      

> θtest -1 01
> θtest [0]
> -1 01
> θtest [1]
> 015 30 45

(b) F IXED BEST -1 0 1    

> θtest [0]
> -1 01
> θtest [1]
> 015 30 45

(c) A DAPT POOL 0.25 -1 0 1    

> θtest [0]
> -1 01
> θtest [1]
> 015 30 45

(d) A DAPT DQN -1 0 1    

> θtest [0]
> -1 01
> θtest [1]
> 0.20.40.60.8

(e) Inference Module 

Figure 4: (a, b, c, d) Heat map of the total rewards obtained by different algorithms when measured in the episode e = 1000 . (e) Heat map of the norm ‖θt − θtest ‖, i.e., the gap between the estimated and true parameter θtest at the end of episode e = 1000 . The performance of the inference procedure is poor in cases when different parameter values of θtest results in agent Ax having equivalent policies. However, in these cases as well, the performance of our algorithms ( ADAPT POOL 0.25 and ADAPT DQN are shown in the figure) is significantly better than the baselines (F IXED BEST is shown in the figure). 

6.3 Results: Performance heatmaps for each θtest 

Here, we provide additional experimental results to gain further insights into the performance of our algorithms. These results are presented in Figure 4 in the form of heat maps for each individual θtest :Heat maps either represent performance of algorithms (in terms of the total reward Jθtest (ALG )) or the performance of inference procedure (in terms of the norm ‖θt − θtest ‖). These results are plotted in the episode e = 1000 (cf., Figure 3 where the performance was plotted over time with increasing e). It is important to note that there are cases where the performance of inference procedure is bad, i.e., ‖θt − θtest ‖ is large. This usually happens when different parameter values of θtest results in agent Ax having equivalent policies. In these cases, estimating the exact θtest without any additional information is difficult. In our experiments, we noted that even if ‖θt − θtest ‖ is large, it is often the case that agent Ax’s policies πxθt and πxθtest are approximately equivalent which is important for getting a good approximation of the transition dynamics Tθtest . Despite the poor performance of the inference module in such cases, the performance of our algorithms (see ADAPT POOL 0.25 and ADAPT DQN in the figure) is significantly better than the baselines (see F IXED BEST in the figure). 

## 7 Related Work 

Modeling and inferring about other agents. The inference problem has been considered in the literature in various forms. For instance, [ Grover et al., 2018 ] consider the problem of learning policy representations that can be used for interacting with unseen agents when using representation-10 conditional policies. They also consider the case of inferring another agent’s representation (pa-rameters) during test time. [ Macindoe et al., 2012 ] consider planners for collaborative domains that can take actions to learn about the intent of another agent or hedge against its uncertainty. [Nikolaidis et al., 2015 ] cluster human users into types and aim to infer the type of new user online, with the goal of executing the policy for that type. They test their approach in robot-human interaction but do not provide any theoretical analysis of their approach. Beyond reinforcement learning, the problem of modeling and inferring about other agents has been studied in other applications such as personalization of web search ranking results by inferring user’s preferences based on their online activity [White et al., 2013, White et al., 2014, Singla et al., 2014]. 

Multi-task and meta-learning. Our problem setting can be interpreted as a multi-task RL problem in which each possible agent Ax corresponds to a different task, or as a meta-learning RL problem in which the goal is to learn a policy that can quickly adapt to new partners. [ Hessel et al., 2019 ] study the problem of multi-task learning in the RL setting in which a single agent has to solve multiple tasks, e.g., solve all Atari games. However, they do not consider a separate test set to measure generalization of trained agents but rather train and evaluate on the same tasks. [ Sæmundsson et al., 2018 ] consider the problem of meta learning for RL in the context of changing dynamics of the environment and approach it using a Gaussian processes and a hierarchical latent variable model approach. 

Robust RL. The idea of robust RL is to learn policies that are robust to certain types of errors or mismatches. In the context of our paper, mismatch occurs in the sense of encountering human agents that have not been encountered at training time and the learned policies should be robust in this situation. [ Pinto et al., 2017 ] consider training of policies in the context of a destabilizing adversary with the goal of coping with model mismatch and data scarcity. [ Roy et al., 2017 ] study the problem of RL under model mismatch such that the learning agent cannot interact with the actual test environment but only a reasonably close approximation. The authors develop robust model-free learning algorithms for this setting. 

More complex interactions, teaching, and steering. In our paper, the type of interaction between two agents is limited as agent Ay does not affect agent Ax’s behaviour, allowing us to gain a deeper theoretical understanding of this setting. There is also a related literature on “steering” the behavior of other agent. For example, (i) the environment design framework of [Zhang et al., 2009], where one agent tries to steer the behavior of another agent by modifying its reward function, (ii) the cooperative inverse reinforcement learning of [ Hadfield-Menell et al., 2016 ], where the human uses demonstrations to reveal a proper reward function to the AI agent, and (iii) the advice-based interaction model [ Amir et al., 2016 ], where the goal is to communicate advice to a sub-optimal agent on how to act. 

Dealing with non-stationary agents. The work of [ Everett and Roberts, 2018 ] is closely related to ours: they design a Switching Agent Model (SAM) that combines deep reinforcement learning with opponent modelling to robustly switch between multiple policies. [ Zheng et al., 2018 ] also consider a similar setting of detecting non-stationarity and reusing policies on the fly, and introduce distilled policy network that serves as the policy library. Our algorithmic framework is similar in spirit to these two papers, however, in our setting, the focus is on acting optimally against an unknown agent whose behavior is stationary and we provide theoretical guarantees on the performance of our algorithms. [ Singla et al., 2018 ] have considered the problem of learning with experts advice where experts are not stationary and are learning agents themselves. However, their focus is on designing a meta-algorithm on how to coordinate with these experts and is technically very different from ours. A few other recent papers have also considered repeated human-AI interaction where the human agent is non-stationary and is evolving its behavior in response to AI agent (see [ Radanovic et al., 2019 , Nikolaidis et al., 2017b ]. Prior work also considers a learner that is aware of the presence of other actors (see [Foerster et al., 2018, Raileanu et al., 2018]). 

## 8 Conclusions 

Inspired by real-world applications like virtual personal assistants, we studied the problem of designing AI agents that can robustly cooperate with new people in human-machine partnerships. Inspired by our motivating applications, we focused on an important practical aspect that there is often a clear distinction between the training and test phase: the explicit reward information is only available during training but adaptation is also needed during testing. We provided a framework for designing adaptive policies and gave theoretical insights into its robustness. In experiments, we demonstrated that these policies can achieve good performance when interacting with previously unseen agents. 11 Acknowledgements 

This work was supported by Microsoft Research through its PhD Scholarship Programme. 

## References 

[Abbeel and Ng, 2004] Abbeel, P. and Ng, A. Y. (2004). Apprenticeship learning via inverse rein-forcement learning. In ICML .[Amershi et al., 2019] Amershi, S., Weld, D., Vorvoreanu, M., Fourney, A., Nushi, B., Collisson, P., Suh, J., Iqbal, S., Bennett, P. N., Inkpen, K., Teevan, J., Kikin-Gil, R., and Horvitz, E. (2019). Guidelines for human-AI interaction. In CHI , pages 3:1–3:13. ACM. [Amir et al., 2016] Amir, O., Kamar, E., Kolobov, A., and Grosz, B. (2016). Interactive teaching strategies for agent training. In IJCAI .[Bobadilla et al., 2012] Bobadilla, J., Ortega, F., Hernando, A., and Bernal, J. (2012). A collaborative filtering approach to mitigate the new user cold start problem. Knowledge-Based Systems , 26:225 – 238. [Dimitrakakis et al., 2017] Dimitrakakis, C., Parkes, D. C., Radanovic, G., and Tylkin, P. (2017). Multi-view decision processes: The helper-AI problem. In Advances in Neural Information Processing Systems .[Even-Dar and Mansour, 2003] Even-Dar, E. and Mansour, Y. (2003). Approximate equivalence of Markov decision processes. In Schölkopf, B. and Warmuth, M. K., editors, Learning Theory and Kernel Machines , pages 581–594, Berlin, Heidelberg. Springer. [Everett and Roberts, 2018] Everett, R. and Roberts, S. J. (2018). Learning against non-stationary agents with opponent modelling and deep reinforcement learning. In AAAI Spring Symposia 2018 .[Foerster et al., 2018] Foerster, J. N., Chen, R. Y., Al-Shedivat, M., Whiteson, S., Abbeel, P., and Mordatch, I. (2018). Learning with opponent-learning awareness. In AAMAS , pages 122–130. [Grover et al., 2018] Grover, A., Al-Shedivat, M., Gupta, J. K., Burda, Y., and Edwards, H. (2018). Learning policy representations in multiagent systems. In ICML , pages 1797–1806. [Hadfield-Menell et al., 2016] Hadfield-Menell, D., Russell, S. J., Abbeel, P., and Dragan, A. D. (2016). Cooperative inverse reinforcement learning. In Advances in Neural Information Processing Systems .[Haug et al., 2018] Haug, L., Tschiatschek, S., and Singla, A. (2018). Teaching inverse reinforcement learners via features and demonstrations. In Advances in Neural Information Processing Systems ,pages 8464–8473. [Hessel et al., 2019] Hessel, M., Soyer, H., Espeholt, L., Czarnecki, W., Schmitt, S., and van Hasselt, H. (2019). Multi-task deep reinforcement learning with popart. In AAAI , pages 3796–3803. [Kamalaruban et al., 2019] Kamalaruban, P., Devidze, R., Cevher, V., and Singla, A. (2019). Inter-active teaching algorithms for inverse reinforcement learning. In IJCAI .[Leibo et al., 2017] Leibo, J. Z., Zambaldi, V. F., Lanctot, M., Marecki, J., and Graepel, T. (2017). Multi-agent reinforcement learning in sequential social dilemmas. In AAMAS , pages 464–473. [Macindoe et al., 2012] Macindoe, O., Kaelbling, L. P., and Lozano-Pérez, T. (2012). Pomcop: Belief space planning for sidekicks in cooperative games. In AIIDE .[Mnih et al., 2015] Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., Graves, A., Riedmiller, M. A., Fidjeland, A., Ostrovski, G., Petersen, S., Beattie, C., Sadik, A., Antonoglou, I., King, H., Kumaran, D., Wierstra, D., Legg, S., and Hassabis, D. (2015). Human-level control through deep reinforcement learning. Nature , 518(7540):529–533. [Nikolaidis et al., 2017a] Nikolaidis, S., Forlizzi, J., Hsu, D., Shah, J. A., and Srinivasa, S. S. (2017a). Mathematical models of adaptation in human-robot collaboration. CoRR , abs/1707.02586. [Nikolaidis et al., 2017b] Nikolaidis, S., Nath, S., Procaccia, A. D., and Srinivasa, S. (2017b). Game-theoretic modeling of human adaptation in human-robot collaboration. In Proceedings of the International conference on human-robot interaction , pages 323–331. 12 [Nikolaidis et al., 2015] Nikolaidis, S., Ramakrishnan, R., Gu, K., and Shah, J. A. (2015). Efficient model learning from joint-action demonstrations for human-robot collaborative tasks. In HRI ,pages 189–196. [Pinto et al., 2017] Pinto, L., Davidson, J., Sukthankar, R., and Gupta, A. (2017). Robust adversarial reinforcement learning. In ICML .[Radanovic et al., 2019] Radanovic, G., Devidze, R., Parkes, D., and Singla, A. (2019). Learning to collaborate in Markov decision processes. In ICML .[Raileanu et al., 2018] Raileanu, R., Denton, E., Szlam, A., and Fergus, R. (2018). Modeling others using oneself in multi-agent reinforcement learning. In ICML , pages 4254–4263. [Roy et al., 2017] Roy, A., Xu, H., and Pokutta, S. (2017). Reinforcement learning under model mismatch. In Advances in Neural Information Processing Systems , pages 3043–3052. [Sæmundsson et al., 2018] Sæmundsson, S., Hofmann, K., and Deisenroth, M. P. (2018). Meta reinforcement learning with latent variable Gaussian processes. In UAI .[Singla et al., 2018] Singla, A., Hassani, S. H., and Krause, A. (2018). Learning to interact with learning agents. In AAAI , pages 4083–4090. [Singla et al., 2014] Singla, A., White, R. W., Hassan, A., and Horvitz, E. (2014). Enhancing personalization via search activity attribution. In SIGIR , pages 1063–1066. [Sutton and Barto, 1998] Sutton, R. S. and Barto, A. G. (1998). Reinforcement learning - an intro-duction . Adaptive computation and machine learning. MIT Press. [Tschiatschek et al., 2019] Tschiatschek, S., Ghosh, A., Haug, L., Devidze, R., and Singla, A. (2019). Learner-aware teaching: Inverse reinforcement learning with preferences and constraints. In Advances in Neural Information Processing Systems .[White et al., 2013] White, R. W., Chu, W., Hassan, A., He, X., Song, Y., and Wang, H. (2013). Enhancing personalized search by mining and modeling task behavior. In WWW , pages 1411–1420. [White et al., 2014] White, R. W., Hassan, A., Singla, A., and Horvitz, E. (2014). From devices to people: Attribution of search activity in multi-user settings. In WWW , pages 431–442. [Wilson and Daugherty, 2018] Wilson, H. J. and Daugherty, P. R. (2018). Collaborative intelligence: Humans and AI are joining forces. Harvard Business Review , 96(4):114–123. [Yu et al., 2017] Yu, H., Miao, C., Leung, C., and White, T. J. (2017). Towards AI-powered personalization in MOOC learning. npj Science of Learning , 2(1):15. [Zhang et al., 2009] Zhang, H., Parkes, D. C., and Chen, Y. (2009). Policy teaching through reward function learning. In EC , pages 295–304. [Zheng et al., 2018] Zheng, Y., Meng, Z., Hao, J., Zhang, Z., Yang, T., and Fan, C. (2018). A deep bayesian policy reuse approach against non-stationary agents. In Advances in Neural Information Processing Systems , pages 962–972. [Ziebart, 2010] Ziebart, B. D. (2010). Modeling Purposeful Adaptive Behavior with the Principle of Maximum Causal Entropy . PhD thesis. 13
